{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: String, key: String) = {
     match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByAddressAndKey(address: String, key: String) = {
     match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}
#end base function

# consts
let SENDTXEXPIRE = 30
let LISTSPLITSYMBOL = "_"
let LISTDATASYMBOL = "+"
let WAVELET = 100000000
let PAULI = 100
let CRYTICALSHARE = 20
let LEASINGSHARE = 90
let LEASINTXCOUNT = 10
let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"
#end consts

#constructor 
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let ReserveContractKey = "reserve_contract"
let AuctionContractKey = "auction_contract"
let RPDContractKey = "rpd_contract"
let ContolContractKey = "control_contract"
let BalanceLockIntervalKey = "balance_lock_interval"
let MinWavesSwapAmountKey = "min_waves_swap_amount"
let MinNeutrinoSwapAmountKey = "min_neutrino_swap_amount"
let NodeAddressKey = "node_address"
let LeasingIntervalKey = "leasing_interval"
#end constructor

# keys
let PriceKey = "price"
let PriceIndexKey = "price_index"
let ScriptUpdateIntervalKey = "script_update_interval"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceUnlockBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderFilledTotalKey = "order_filled_total_"
let OrderStatusKey = "order_status_"
let RPDSyncIndexKey = "rpd_sync_index"
let RPDProfitKey = "rpd_profit"
let RPDBalanceKey = "rpd_balance"
let IsBlockedKey = "is_blocked"
let IsLeasingProfitTxExistKey = "is_leasing_profit"
let ScriptUpdateBlockKey = "script_update_block"
let LeaseTxKey = "lease_tx"
let LeaseTxStatusKey = "lease_tx_status"
let LeasingAmountKey = "leasing_amount"
let LeaseTxExpireSendBlockKey = "leasing_expire_send"
let LeasingExpireBlockKey = "leasing_expire_block"
let IsRebalanceKey = "is_rebalance"
let SwapLockedBalanceKey = "swap_locked_balance"
let SwapNeutrinoLockedBalanceKey = "swap_neutrino_locked_balance"
let LeasingTxCountKey = "leasing_index"

func getRPDSnapshotContractBalanceKey(count: Int, assetId: ByteVector) = RPDBalanceKey + "_" + toBase58String(assetId) + "_" + toString(count)
func getRPDContractBalanceKey(assetId: ByteVector) = RPDBalanceKey + "_" + toBase58String(assetId)
func getRPDProfitKey(count: Int) = RPDProfitKey + "_" + toString(count)
func getNeutrinoBalanceKey(owner: String) = NeutrinoBalanceKey + owner
func getWavesBalanceKey(owner: String) = WavesBalanceKey + owner
func getBalanceUnlockBlockKey(owner: String) = BalanceUnlockBlockKey + owner
func getOrderTotalKey(orderId: String) = OrderTotalKey + orderId
func getOrderOwnerKey(orderId: String) = OrderOwnerKey + orderId
func getOrderHeightKey(orderId: String) = OrderHeightKey + orderId
func getOrderStatusKey(orderId: String) = OrderStatusKey + orderId
func getOrderFilledTotalKey(orderId: String) = OrderFilledTotalKey + orderId
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)
func getHeightPriceByIndexKey(index: Int) = PriceIndexKey + "_" + toString(index)
func getLeaseTxStatusKey(hash: String) = LeaseTxStatusKey + "_" + hash
func getLeaseTxAmountByHashKey(hash: String) = LeasingAmountKey + "_" + hash
func getLeaseTxBytesByHashKey(hash: String) = LeaseTxKey + "_" + hash
func getLeaseTxExpireSendBlockKey(hash: String) = LeaseTxExpireSendBlockKey + "_" + hash
func getIsRebalanceByAddressKey(address: String) = IsRebalanceKey + "_" + address
#end keys

let controlContract = getStringByKey(ContolContractKey)
let price = getNumberByAddressAndKey(controlContract,PriceKey)
let priceIndex = getNumberByAddressAndKey(controlContract, PriceIndexKey)

#convert func
func convertNeutrinoToWavesByPrice(amount: Int, convertPrice: Int) = amount*100/convertPrice*WAVELET/PAULI
func convertNeutrinoToWaves(amount: Int) = amount*100/price*WAVELET/PAULI
func convertWavesToNeutrino(amount: Int) = amount*price/100*PAULI/WAVELET 
func convertNeutrinoToBond(amount: Int) = amount/PAULI 
func convertBondToNeutrino(amount: Int) = amount*PAULI 
func convertWavesToBond(amount: Int) = convertNeutrinoToBond(convertWavesToNeutrino(amount))
#end convert func

#global vars
let leasingTxCount = getNumberByKey(LeasingTxCountKey)
let isRebalance = getBoolByKey(IsRebalanceKey)
let leasingInterval = getNumberByKey(LeasingIntervalKey)
let leasingExpireBlock = getNumberByKey(LeasingExpireBlockKey)
let leasingAmount = getNumberByKey(LeasingAmountKey)
let swapNeutrinoLockedBalance = getNumberByKey(SwapNeutrinoLockedBalanceKey) 
let swapWavesLockedBalance = getNumberByKey(SwapLockedBalanceKey) # backward compatibility
let nodeAddress = getStringByKey(NodeAddressKey)
let scriptUpdateInterval = getNumberByAddressAndKey(ContolContractKey, ScriptUpdateIntervalKey)
let scriptUpdateBlock = getNumberByAddressAndKey(controlContract,ScriptUpdateBlockKey)
let rpdSyncIndex = getNumberByKey(RPDSyncIndexKey)
let balanceLockInterval = getNumberByKey(BalanceLockIntervalKey)
let isBlocked = getBoolByAddressAndKey(controlContract,IsBlockedKey)
let minWavesSwapAmount = getNumberByKey(MinWavesSwapAmountKey)
let minNeutrinoSwapAmount = getNumberByKey(MinNeutrinoSwapAmountKey)
let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let reserveContract = getStringByKey(ReserveContractKey)
let auctionContract = getStringByKey(AuctionContractKey)
let rpdContract = getStringByKey(RPDContractKey)
let reserve = wavesBalance(this) - swapWavesLockedBalance
let reserveWithoutLeasing = reserve - leasingAmount
let orderbook = getStringByKey(OrderbookKey)
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}
let neutrinoSupply = {
    let info = extract(assetInfo(neutrinoAssetId))
    info.quantity - assetBalance(this, neutrinoAssetId) + swapNeutrinoLockedBalance
}
let surplus = convertWavesToNeutrino(reserve) - neutrinoSupply
let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)

#end global vars

# get func

func getRPDContractBalance(assetId: ByteVector) = getNumberByAddressAndKey(rpdContract, getRPDContractBalanceKey(assetId))
func getWavesBalance(owner : String) = getNumberByKey(getWavesBalanceKey(owner))
func getNeutrinoBalance(owner : String) = getNumberByKey(getNeutrinoBalanceKey(owner))
func getUnlockBalanceBlock(owner : String) = getNumberByKey(getBalanceUnlockBlockKey(owner))
func getOrderTotal(id : String) = getNumberByKey(getOrderTotalKey(id))
func getOrderOwner(id : String) = getStringByKey(getOrderOwnerKey(id))
func getOrderStatus(id : String) = getStringByKey(getOrderStatusKey(id))
func getOrderFilledTotal(id : String) = getNumberByKey(getOrderFilledTotalKey(id))
func getRPDProfit(count: Int) = getNumberByKey(getRPDProfitKey(count))
func getPriceHistory(block: Int) = getNumberByAddressAndKey(controlContract, getPriceHistoryKey(block))
func getHeightPriceByIndex(index: Int) = getNumberByAddressAndKey(controlContract, getHeightPriceByIndexKey(index))
func getLeaseTxStatus(hash: String) = getStringByKey(getLeaseTxStatusKey(hash)) 
func getLeaseTxAmountByHash(hash: String) = getNumberByKey(getLeaseTxAmountByHashKey(hash)) 
func getLeaseTxBytesByHash(hash: String) = getStringByKey(getLeaseTxBytesByHashKey(hash)) 
func getLeaseTxExpireSendBlock(hash: String) = getNumberByKey(getLeaseTxExpireSendBlockKey(hash)) 
func isRebalanceByAddress(address: String) = getBoolByKey(getIsRebalanceByAddressKey(address))
#end get func

#other function
func getOrderElementById(id : String) = id + LISTSPLITSYMBOL
func addOrder(orderId: String) = {
    orderbook + getOrderElementById(orderId)
}
func dropOrder(orderId: String) = {
    let parts = orderbook.split(getOrderElementById(orderId))
    parts[0] + parts[1]
}

#end other function

#-------------------Callable----------------------

@Callable(i)
func swapWavesToNeutrino() = {
    let pmt = extract(i.payment)
    if (pmt.amount < minWavesSwapAmount)
        then throw("amount less min")
    else if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else if(isBlocked)
        then throw("contract is blocked")
    else{
        let amount = convertWavesToNeutrino(pmt.amount)
        TransferSet([
            ScriptTransfer(i.caller, amount, neutrinoAssetId)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let pmt = extract(i.payment)
    let account = toString(i.caller)
    if (pmt.amount < minNeutrinoSwapAmount)
        then throw("amount less min")
    else if(isBlocked)
        then throw("contract is blocked")
    else if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else if(getUnlockBalanceBlock(account) > height)
        then throw("await " + toString(getUnlockBalanceBlock(account) - height) + " blocks")
    else if (getNeutrinoBalance(account) != 0)
        then throw("use withdraw")
    else{
        let neutrinoAmount = pmt.amount
        let amount = convertNeutrinoToWaves(neutrinoAmount)
        WriteSet([
            DataEntry(getNeutrinoBalanceKey(account), getNeutrinoBalance(account) + neutrinoAmount),
            DataEntry(getBalanceUnlockBlockKey(account), height + balanceLockInterval),
            DataEntry(IsRebalanceKey, (reserveWithoutLeasing - amount) <= reserve*CRYTICALSHARE/100),
            DataEntry(SwapNeutrinoLockedBalanceKey, swapNeutrinoLockedBalance + neutrinoAmount)
        ])
    }
}

@Callable(i)
func withdraw(account : String, index: Int) = {
    let indexHeight = getHeightPriceByIndex(index)
    let nextIndexHeight = getHeightPriceByIndex(index+1)
    let unlockHeight = getUnlockBalanceBlock(account)
    let neutrinoAmount = getNeutrinoBalance(account)
    let indexPrice = getPriceHistory(indexHeight)
    let amount = convertNeutrinoToWavesByPrice(neutrinoAmount, indexPrice)
    let totalWavesWithdraw = getWavesBalance(account) + amount # getWavesBalance(account) is backward compatibility

    if(totalWavesWithdraw > reserveWithoutLeasing) then {
        if(!isRebalance) then {
            throw("TODO")
        }else throw("wait rebalance")
    }
    else if(isBlocked)
        then throw("contract is blocked") 
    else if(unlockHeight > height)
        then throw("wait a couple of blocks for withdraw")
    else if(index > priceIndex || unlockHeight < indexHeight || (nextIndexHeight != 0 && unlockHeight >= nextIndexHeight))
        then throw("invalid index")
    else {   
        ScriptResult(
            WriteSet([
                DataEntry(getWavesBalanceKey(account), 0), # backward compatibility
                DataEntry(getNeutrinoBalanceKey(account), 0), # backward compatibility
                DataEntry(SwapLockedBalanceKey, swapWavesLockedBalance - getWavesBalance(account)), # backward compatibility
                DataEntry(SwapNeutrinoLockedBalanceKey, swapNeutrinoLockedBalance - neutrinoAmount)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(account), totalWavesWithdraw, unit) 
            ])
        )
    }
}

@Callable(i)
func generateBond() = {
    let balanceAuction = assetBalance(addressFromStringValue(auctionContract), bondAssetId)
    let amount = convertNeutrinoToBond(deficit) - balanceAuction
    if(isBlocked)
        then throw("contract is blocked") 
    else if(amount >= 10)
        then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), amount, bondAssetId)])
    else throw("bond were generated or do not need it")
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))
    
    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookKey, addOrder(newOrderId)),

            DataEntry(getOrderTotalKey(newOrderId), pmt.amount),
            DataEntry(getOrderOwnerKey(newOrderId), toString(i.caller)),
            DataEntry(getOrderHeightKey(newOrderId), height),
            DataEntry(getOrderStatusKey(newOrderId), NEW)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else if(getOrderStatus(orderId) != NEW)
        then throw("invalid order status")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, dropOrder(orderId)),
                DataEntry(getOrderStatusKey(orderId), CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, bondAssetId)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderId = orderbook.split(LISTSPLITSYMBOL)[0]
    let orderTotal = getOrderTotal(orderId)
    let orderOwner = getOrderOwner(orderId)
    let filledTotal = getOrderFilledTotal(orderId)

    let surplusBond = convertNeutrinoToBond(surplus)
    
    if(isBlocked)
        then throw("contract is blocked") 
    else if(surplusBond <= 0) 
        then throw("surplus is less than zero")
    else if(orderOwner == "" && surplusBond >= 10) then {
        let newRpdSyncIndex = rpdSyncIndex + 1
        ScriptResult(
            WriteSet([
                DataEntry(RPDSyncIndexKey, newRpdSyncIndex),
                DataEntry(getRPDProfitKey(rpdSyncIndex), surplus),
                DataEntry(getRPDSnapshotContractBalanceKey(rpdSyncIndex, neutrinoAssetId), getRPDContractBalance(neutrinoAssetId))
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(rpdContract), surplus, neutrinoAssetId)
            ])
        )
    }
    else {
        let amount = orderTotal-filledTotal;
        let status = if(surplusBond >= amount) then FILLED else NEW
        let newFilledTotal = if(surplusBond >= amount) then amount else surplusBond

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, if(surplusBond >= amount) then dropOrder(orderId) else orderbook),
                DataEntry(getOrderFilledTotalKey(orderId), filledTotal + newFilledTotal),
                DataEntry(getOrderStatusKey(orderId), status)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(newFilledTotal), neutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func transfer(account: String) = {
    let pmt = extract(i.payment)
    TransferSet([ScriptTransfer(addressFromStringValue(account), pmt.amount, pmt.assetId)])
}

@Callable(i)
func nodeReward() = {
    let pmt = value(i.payment)
    if(i.caller != addressFromStringValue(nodeAddress))
        then throw("permission denied")
    else if(isDefined(pmt.assetId))
        then throw("waves only")
    else {
        let amount = convertWavesToNeutrino(pmt.amount)
        let newRpdSyncIndex = rpdSyncIndex + 1
        ScriptResult(
            WriteSet([
                DataEntry(RPDSyncIndexKey, newRpdSyncIndex),
                DataEntry(getRPDProfitKey(rpdSyncIndex), amount),
                DataEntry(getRPDSnapshotContractBalanceKey(rpdSyncIndex, neutrinoAssetId), getRPDContractBalance(neutrinoAssetId))
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(rpdContract), amount, neutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func registrationLeaseTx(senderPublicKey: String, fee: Int, timestamp: Int, leaseTxHash: String) = {
    let totalFreeReserve = reserve*LEASINGSHARE/100
    let amount = totalFreeReserve/LEASINTXCOUNT
    let txBytes = base64'CAIA' + fromBase58String(senderPublicKey) + fromBase58String(nodeAddress) + toBytes(amount) + toBytes(fee) + toBytes(timestamp)
    let txHashBytes = blake2b256(txBytes)
    let txHash = toBase58String(txHashBytes)
    
    if(leaseTxHash != txHash)
        then throw("invalid tx hash")
    else if(leasingTxCount >= LEASINTXCOUNT)
        then throw("the number of leasing transactions is equal to the maximum")
    else if(this != addressFromPublicKey(fromBase58String(senderPublicKey)))
        then throw("invalid pubKey")
    else if(timestamp < lastBlock.timestamp || timestamp > lastBlock.timestamp + 5400000) 
        then throw("invalid timestamp(lastBlock: " + toString(lastBlock.timestamp) + ")")
    else if(getLeaseTxStatus(txHash) == "")
        then throw("tx is exist")
    else if(fee > 1000000 || fee < 500000)
        then throw("invalid fee")
    else if(totalFreeReserve-(leasingAmount + amount) > reserveWithoutLeasing)
        then throw("invalid amount(result:" + toString(reserve-(leasingAmount + amount) > reserveWithoutLeasing) + ")")
    else {
        WriteSet([
            DataEntry(LeasingTxCountKey, if(getLeaseTxStatus(txHash) == "") then leasingTxCount + 1 else leasingTxCount),
            DataEntry(LeasingAmountKey, leasingAmount + amount),
            DataEntry(LeasingExpireBlockKey, if(leasingExpireBlock > height) then height + leasingInterval else leasingExpireBlock),
            DataEntry(getLeaseTxStatusKey(txHash), NEW),
            DataEntry(getLeaseTxExpireSendBlockKey(txHash), height + SENDTXEXPIRE),
            DataEntry(getLeaseTxAmountByHashKey(txHash), amount),
            DataEntry(getLeaseTxBytesByHashKey(txHash), toBase64String(txBytes))
        ])
    }
}
@Callable(i)
func cancelStuckLeaseTx(txHash: String) = {
    if(getLeaseTxStatus(txHash) == NEW && !isDefined(transactionHeightById(fromBase58String(txHash))) && height > getLeaseTxExpireSendBlock(txHash)) then {
        WriteSet([
            DataEntry(LeasingTxCountKey, leasingTxCount - 1),
            DataEntry(LeasingAmountKey, leasingAmount - getLeaseTxAmountByHash(txHash)),
            DataEntry(getLeaseTxStatusKey(txHash), CANCELED)
        ])
    } else throw("invalid tx hash")
}

@Callable(i)
func registrationUnleaseTx(chainIdString: String, senderPublicKey: String, fee: Int, timestamp: Int, leaseTxHash: String) = {
    let txBytes = base64'CQI=' + toBytes(chainIdString) + fromBase58String(senderPublicKey) + toBytes(fee) + toBytes(timestamp) + fromBase58String(leaseTxHash)
    let txHash = blake2b256(txBytes)

    if(getLeaseTxStatus(leaseTxHash) != NEW)
        then throw("invalid tx status")
    else if(this != addressFromPublicKey(fromBase58String(senderPublicKey)))
        then throw("invalid pubKey")
    else if(!isDefined(transactionHeightById(txHash)))
        then throw("blockchain does not contain this transaction")
    else {
        WriteSet([
            DataEntry(LeasingTxCountKey, leasingTxCount - 1),
            DataEntry(LeasingAmountKey, leasingAmount - getLeaseTxAmountByHash(leaseTxHash)),
            DataEntry(getLeaseTxStatusKey(leaseTxHash), CANCELED)
           #TODO DataEntry(IsRebalanceKey, if(swapNeutrinoLockedBalance))
        ])
    }
}

@Verifier(tx)
func verify() = {
    let id = toBase58String(tx.id)
    match tx {
        case leaseTx: LeaseTransaction =>
            height <= leasingExpireBlock && height <= getLeaseTxExpireSendBlock(id) && getLeaseTxStatusKey(id) == NEW
        case unleaseTx: LeaseCancelTransaction =>
            (leasingExpireBlock > height || isRebalance) && (unleaseTx.fee >= 500000 && unleaseTx.fee <= 1000000) && getLeaseTxStatusKey(toBase58String(unleaseTx.leaseId)) == NEW
        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
    }
}