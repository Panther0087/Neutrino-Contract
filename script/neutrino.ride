{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: String, key: String) = {
     match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func isInt(val: Int|Unit) = {
     match val {
            case a:Int => true
            case _ => false
    }
}
#end base function

# consts
let LISTSPLITSYMBOL = "_"
let LISTDATASYMBOL = "+"
let WAVELET = 100000000
let PAULI = 100
let CRYTICALSHARE = 20
let LEASINGSHARE = 50
let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"
let BLOCK = "block"
let UNBLOCK = "unblock"
let UPDATE = "update"
#end consts

#constructor 
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let RPDContractKey = "rpd_contract"
let BalanceLockIntervalKey = "balance_lock_interval"
let VoteIntervalKey = "vote_interval"
let MinWavesSwapAmountKey = "min_waves_swap_amount"
let MinNeutrinoSwapAmountKey = "min_neutrino_swap_amount"
let PriceOffsetKey = "price_offset"
let ProvidingIntervalKey = "providing_interval"
let CoefficientOracleKey = "coefficient_oracle"
let CoefficientAdminKey = "coefficient_admin"
let ScriptUpdateIntervalKey = "script_update_interval"
let NodeAddressKey = "node_address"
let LeasingIntervalKey = "leasing_interval"
#end constructor

# keys
let PriceKey = "price"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceUnlockBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderFilledTotalKey = "order_filled_total_"
let OrderStatusKey = "order_status_"
let RPDSyncIndexKey = "rpd_sync_index"
let RPDProfitKey = "rpd_profit"
let RPDBalanceKey = "rpd_balance"
let IsBlockedKey = "is_blocked"
let BlackSwarmPriceKey = "black_swarm_price"
let AdminVoteKey = "admin_vote_"
let BlockExpireVoteKey = "vote_expire_block"
let AdminsKey = "admins"
let IsPricePendingKey = "is_pending_price"
let OraclesKey = "oracles"
let OracleIsProvideKey = "oracle_is_provide_"
let OracleProvidePriceKey = "oracle_price_provide_"
let BlockExpireProvidingKey = "providing_expire_block"
let IsLeasingProfitTxExistKey = "is_leasing_profit"
let ActionKey = "action"
let ArgsKey = "args"
let ScriptUpdateBlockKey = "script_update_block"
let LeaseTxKey = "lease_tx"
let LeasingAmountKey = "leasing_amount"
let LeaseTxExpireSendBlockKey = "leasing_expire_send"
let LeasingExpireBlockKey = "leasing_expire_block"
let IsRebalanceKey = "rebalance_key"
let SwapLockedBalanceKey = "swap_locked_balance"

func getAdminVoteKey(owner: String) = AdminVoteKey + owner
func getAdminVoteActionKey(owner: String) = getAdminVoteKey(owner) + "_" + ActionKey
func getAdminVoteArgsKey(owner: String) = getAdminVoteKey(owner) + "_" + ArgsKey

func getOracleIsProvideKey(owner: String) = OracleIsProvideKey + owner
func getOracleProvidePriceKey(owner: String) = OracleProvidePriceKey + owner

func getRPDSnapshotContractBalanceKey(count: Int, assetId: ByteVector) = RPDBalanceKey + "_" + toBase58String(assetId) + "_" + toString(count)
func getRPDContractBalanceKey(assetId: ByteVector) = RPDBalanceKey + "_" + toBase58String(assetId)
func getRPDProfitKey(count: Int) = RPDProfitKey + "_" + toString(count)
func getNeutrinoBalanceKey(owner: String) = NeutrinoBalanceKey + owner
func getWavesBalanceKey(owner: String) = WavesBalanceKey + owner
func getBalanceUnlockBlockKey(owner: String) = BalanceUnlockBlockKey + owner
func getBlackSwarmPriceKey(block: Int) = BlackSwarmPriceKey + "_" + toString(block)
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)

func getOrderTotalKey(orderId: String) = OrderTotalKey + orderId
func getOrderOwnerKey(orderId: String) = OrderOwnerKey + orderId
func getOrderHeightKey(orderId: String) = OrderHeightKey + orderId
func getOrderStatusKey(orderId: String) = OrderStatusKey + orderId
func getOrderFilledTotalKey(orderId: String) = OrderFilledTotalKey + orderId
#end keys

let price = getNumberByKey(PriceKey)
#convert func
func convertNeutrinoToWaves(amount: Int) = amount*100/price*WAVELET/PAULI
func convertWavesToNeutrino(amount: Int) = amount*price/100*PAULI/WAVELET 
func convertNeutrinoToBond(amount: Int) = amount/PAULI 
func convertBondToNeutrino(amount: Int) = amount*PAULI 
func convertWavesToBond(amount: Int) = convertNeutrinoToBond(convertWavesToNeutrino(amount))
#end convert func

#global vars
let isRebalance = getBoolByKey(IsRebalanceKey)
let leasingInterval = getNumberByKey(LeasingIntervalKey)
let leaseTxExpireSendBlock = getNumberByKey(LeaseTxExpireSendBlockKey)
let leasingExpireBlock = getNumberByKey(LeasingExpireBlockKey)
let leaseTxHash = getStringByKey(LeaseTxKey) 
let leasingAmount = getNumberByKey(LeasingAmountKey)

let swapLockedBalance = getNumberByKey(SwapLockedBalanceKey)
let nodeAddress = getStringByKey(NodeAddressKey)
let scriptUpdateInterval = getNumberByKey(ScriptUpdateIntervalKey)
let scriptUpdateBlock = getNumberByKey(ScriptUpdateBlockKey)
let providingInterval = getNumberByKey(ProvidingIntervalKey)
let blockExpireProviding = getNumberByKey(BlockExpireProvidingKey)
let isPricePending = getBoolByKey(IsPricePendingKey)
let percentPriceOffset = getNumberByKey(PriceOffsetKey)
let rpdSyncIndex = getNumberByKey(RPDSyncIndexKey)
let voteInterval = getNumberByKey(VoteIntervalKey)
let blockExpireVote = getNumberByKey(BlockExpireVoteKey)
let balanceLockInterval = getNumberByKey(BalanceLockIntervalKey)
let isBlocked = getBoolByKey(IsBlockedKey)
let minWavesSwapAmount = getNumberByKey(MinWavesSwapAmountKey)
let minNeutrinoSwapAmount = getNumberByKey(MinNeutrinoSwapAmountKey)
let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let auctionContract = getStringByKey(AuctionContractKey)
let rpdContract = getStringByKey(RPDContractKey)
let reserve = wavesBalance(this) + leasingAmount - swapLockedBalance
let orderbook = getStringByKey(OrderbookKey)
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}
let neutrinoSupply = {
    let info = extract(assetInfo(neutrinoAssetId))
    info.quantity - assetBalance(this, neutrinoAssetId)
}
let surplus = convertWavesToNeutrino(reserve) - neutrinoSupply

let oracles = getStringByKey(OraclesKey) # json array
let admins = getStringByKey(AdminsKey) # json array

let bftCoefficientOracle = getNumberByKey(CoefficientOracleKey)
let bftCoefficientAdmin = getNumberByKey(CoefficientAdminKey)
#end global vars

# get func

func getRPDContractBalance(assetId: ByteVector) = getNumberByAddressAndKey(rpdContract, getRPDContractBalanceKey(assetId))

func getAdminVoteAction(owner: String) = getStringByKey(getAdminVoteActionKey(owner))

func isOracleProvide(owner: String) = getBoolByKey(getOracleIsProvideKey(owner))
func isOracleProvideInt(owner: String) = if(isOracleProvide(owner)) then 1 else 0
func getOracleProvidePrice(owner: String) = getNumberByKey(getOracleProvidePriceKey(owner))

func getWavesBalance(owner : String) = getNumberByKey(getWavesBalanceKey(owner))
func getNeutrinoBalance(owner : String) = getNumberByKey(getNeutrinoBalanceKey(owner))
func getUnlockBalanceBlock(owner : String) = getNumberByKey(getBalanceUnlockBlockKey(owner))
func getOrderTotal(id : String) = getNumberByKey(getOrderTotalKey(id))
func getOrderOwner(id : String) = getStringByKey(getOrderOwnerKey(id))
func getOrderFilledTotal(id : String) = getNumberByKey(getOrderFilledTotalKey(id))
func getRPDProfit(count: Int) = getNumberByKey(getRPDProfitKey(count))
#end get func

func filterAdminsVoteByAction(result: List[String], address: String, action: String) = 
   address :: result

func convertJsonArrayToList(jsonArray: String) = {
    jsonArray.drop(1).dropRight(1).split(",")
}
func isOracle(address: String) = {
    match(indexOf(oracles.drop(1).dropRight(1), address)) {
        case _: Int => true
        case _ => false
    }
}
func isAdmin(address: String) = {
    match(indexOf(admins.drop(1).dropRight(1), address)) {
        case _: Int => true
        case _ => false
    }
}

func getOrderElementById(id : String) = id + LISTSPLITSYMBOL
func addOrder(orderId: String) = {
    orderbook + getOrderElementById(orderId)
}
func dropOrder(orderId: String) = {
    let parts = orderbook.split(getOrderElementById(orderId))
    parts[0] + parts[1]
}
func dropElementInJsonArray(array: String, element: String) = {
    let splitedArray = array.split(element)
    if(splitedArray[0].take(1) == "[") then
        splitedArray[0] + splitedArray[1].drop(1)
    else 
        splitedArray[0].dropRight(1) + splitedArray[1]
}

# FOLD func
func sumOraclePrice(base: Int, address: String) = 
   base + getOracleProvidePrice(address)*isOracleProvideInt(address)

func filterIsOracleProvide(result: List[String], address: String) = 
   if (isOracleProvide(address)) then address :: result else result

func filterAdminsVoteByBlockAction(result: List[String], address: String) = 
   filterAdminsVoteByAction(result, address, BLOCK)

func filterAdminsVoteByUnblockAction(result: List[String], address: String) = 
   filterAdminsVoteByAction(result, address, UNBLOCK)

func filterAdminsVoteByUpdateAction(result: List[String], address: String) = 
   filterAdminsVoteByAction(result, address, UPDATE)

func addDataEntry(result: List[DataEntry], data: DataEntry) = 
    data :: result

func getResetVoteDataEntries(result: List[DataEntry], address: String) = 
    DataEntry(getAdminVoteActionKey(address), "") :: result

func getDataEntryOracleProviding(result: List[DataEntry], address: String) = 
    DataEntry(getOracleIsProvideKey(address), if(height > blockExpireProviding) then false else isOracleProvide(address)) :: result

#end FOLD func

#-------------------Callable----------------------

@Callable(i)
func setCurrentPrice(newPrice : Int) = {
    let account = toString(i.caller)
    let oraclesList = convertJsonArrayToList(oracles)
    let priceProvidingCount = size(FOLD<5>(oraclesList, [], filterIsOracleProvide))
    let oracleDataEntries = FOLD<5>(oraclesList, [], getDataEntryOracleProviding)
    if(isBlocked)
        then throw("contract is blocked")
    else if(!isOracle(account))
        then throw("permission denied")
    else if(height <= blockExpireProviding &&  isOracleProvide(account))
        then throw("price is already provided")
    else if(height > blockExpireProviding && isPricePending)
        then throw("use finilizeCurrentPrice")
    else {
        let dataEntries = [
            DataEntry(getOracleProvidePriceKey(account), newPrice),
            DataEntry(BlockExpireProvidingKey, if(height > blockExpireProviding) then height + providingInterval else blockExpireProviding),
            DataEntry(getOracleIsProvideKey(account), true),
            DataEntry(IsPricePendingKey, if(height <= blockExpireProviding && priceProvidingCount >= 2) then true else isPricePending)
        ]
        WriteSet(FOLD<4>(dataEntries, oracleDataEntries, addDataEntry))
    }
}

@Callable(i)
func finilizeCurrentPrice() = {
    let account = toString(i.caller)
    let oraclesList = convertJsonArrayToList(oracles)
    let priceProvidingCount = size(FOLD<5>(oraclesList, [], filterIsOracleProvide))

    let newPrice = FOLD<5>(oraclesList, 0, sumOraclePrice)/priceProvidingCount
    
    if(isBlocked)
        then throw("contract is blocked")
    else if(!isPricePending || height <= blockExpireProviding)
        then throw("wait for the end of the price providing")
    else if(priceProvidingCount < bftCoefficientOracle)
        then throw("2/3 oracles need to set a price")
    else if(newPrice >= (price + price*percentPriceOffset/100) || newPrice <= (price - price*percentPriceOffset/100)) then {
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(getBlackSwarmPriceKey(height), newPrice)
        ])
    }
    else 
        WriteSet([
            DataEntry(PriceKey, newPrice),
            DataEntry(getPriceHistoryKey(height), newPrice),
            DataEntry(IsPricePendingKey, false)
        ])
}

@Callable(i)
func vote(action: String) = {
    let account = toString(i.caller)
    let adminsListWithoutAccount = convertJsonArrayToList(dropElementInJsonArray(admins, account))
    let lastAction = getAdminVoteAction(account) 
    
    let blockVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByBlockAction)
    let unblockVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByUnblockAction)
    let updateVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByUpdateAction)
    
    let blockVoteCount = size(blockVotes) + if( action == BLOCK) then 1 else 0 
    let unblockVoteCount = size(unblockVotes) + if( action == UNBLOCK) then 1 else 0 
    let updateVotesCount = size(updateVotes) + if( action == UPDATE) then 1 else 0 

    let resetVotes = FOLD<5>(adminsListWithoutAccount, [DataEntry(getAdminVoteActionKey(account), "")], getResetVoteDataEntries)
   
    if(blockVoteCount >= bftCoefficientAdmin || unblockVoteCount >= bftCoefficientAdmin) then {
        let dataEntries = [
            DataEntry(IsBlockedKey, if(blockVoteCount >= bftCoefficientAdmin) then true else false),
            DataEntry(BlockExpireVoteKey, 0),
            DataEntry(BlockExpireProvidingKey, 0),
            DataEntry(IsPricePendingKey, false)
        ]
        let data = FOLD<4>(dataEntries, resetVotes, addDataEntry)
        WriteSet(data)
    }
    else if(updateVotesCount > bftCoefficientAdmin) then {
        let dataEntries = [
            DataEntry(BlockExpireVoteKey, 0),
            DataEntry(BlockExpireProvidingKey, 0),
            DataEntry(ScriptUpdateBlockKey, height + scriptUpdateInterval)
        ]
        let data = FOLD<3>(dataEntries, resetVotes, addDataEntry)
        WriteSet(data)
    }
    else if(height > blockExpireVote) then {
        let dataEntries = [
            DataEntry(BlockExpireVoteKey, height + voteInterval),
            DataEntry(getAdminVoteActionKey(account), action)
        ]
        let data = FOLD<2>(dataEntries, resetVotes, addDataEntry)
        WriteSet(data)
    }
    else {
        WriteSet([
            DataEntry(getAdminVoteActionKey(account), action)
        ])
    }
}

@Callable(i)
func swapWavesToNeutrino() = {
    let pmt = extract(i.payment)
    if (pmt.amount < minWavesSwapAmount)
        then throw("amount less min")
    else if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else if(isBlocked)
        then throw("contract is blocked")
    else{
        let amount = convertWavesToNeutrino(pmt.amount)
        TransferSet([
            ScriptTransfer(i.caller, amount, neutrinoAssetId)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let pmt = extract(i.payment)
    if (pmt.amount < minNeutrinoSwapAmount)
        then throw("amount less min")
    else if(isBlocked)
        then throw("contract is blocked")
    else if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertNeutrinoToWaves(pmt.amount)
        WriteSet([
            DataEntry(getWavesBalanceKey(account), getWavesBalance(account) + amount),
            DataEntry(getBalanceUnlockBlockKey(account), height + balanceLockInterval),
            DataEntry(IsRebalanceKey, (wavesBalance(this) - amount - swapLockedBalance) <= reserve*CRYTICALSHARE/100),
            DataEntry(SwapLockedBalanceKey, swapLockedBalance + amount)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getUnlockBalanceBlock(account) > height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(getWavesBalanceKey(account), 0),
                DataEntry(getNeutrinoBalanceKey(account), 0),
                DataEntry(SwapLockedBalanceKey, swapLockedBalance - getWavesBalance(account))
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(account), getNeutrinoBalance(account), neutrinoAssetId),
                ScriptTransfer(addressFromStringValue(account), getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)
    let balanceAuction = assetBalance(addressFromStringValue(auctionContract), bondAssetId)
    let amount = convertNeutrinoToBond(deficit) - balanceAuction
    if(isBlocked)
        then throw("contract is blocked") 
    else if(amount > 0)
        then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), amount, bondAssetId)])
    else throw("bond were generated or do not need it")
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookKey, addOrder(newOrderId)),

            DataEntry(getOrderTotalKey(newOrderId), pmt.amount),
            DataEntry(getOrderOwnerKey(newOrderId), toString(i.caller)),
            DataEntry(getOrderHeightKey(newOrderId), height),
            DataEntry(getOrderStatusKey(newOrderId), NEW)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, dropOrder(orderId)),
                DataEntry(getOrderStatusKey(orderId), CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, bondAssetId)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderId = orderbook.split(LISTSPLITSYMBOL)[0]
    let orderTotal = getOrderTotal(orderId)
    let orderOwner = getOrderOwner(orderId)
    let filledTotal = getOrderFilledTotal(orderId)

    if(isBlocked)
        then throw("contract is blocked") 
    else if(surplus <= 0) 
        then throw("surplus is less than zero")
    else if(orderOwner == "") then {
        let newRpdSyncIndex = rpdSyncIndex + 1
        ScriptResult(
            WriteSet([
                DataEntry(RPDSyncIndexKey, newRpdSyncIndex),
                DataEntry(getRPDProfitKey(rpdSyncIndex), surplus),
                DataEntry(getRPDSnapshotContractBalanceKey(rpdSyncIndex, bondAssetId), getRPDContractBalance(bondAssetId))
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(rpdContract), surplus, neutrinoAssetId)
            ])
        )
    }
    else {
        let amount = orderTotal-filledTotal;
        let surplusBond = convertNeutrinoToBond(surplus)
        let status = if(surplusBond >= amount) then FILLED else NEW
        let newFilledTotal = if(surplusBond >= amount) then orderTotal else surplusBond

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, dropOrder(orderId)),
                DataEntry(getOrderFilledTotalKey(orderId), filledTotal + newFilledTotal),
                DataEntry(getOrderStatusKey(orderId), status)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(newFilledTotal), neutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func transfer(account: String) = {
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId))
        then throw("can use waves only at the moment")
    else TransferSet([ScriptTransfer(addressFromStringValue(account), pmt.amount, unit)])
}

@Callable(i)
func nodeReward() = {
    let pmt = value(i.payment)
    if(i.caller != addressFromStringValue(nodeAddress))
        then throw("permission denied")
    else if(isDefined(pmt.assetId))
        then throw("waves only")
    else {
        let amount = convertWavesToNeutrino(pmt.amount)
        let newRpdSyncIndex = rpdSyncIndex + 1
        ScriptResult(
            WriteSet([
                DataEntry(RPDSyncIndexKey, newRpdSyncIndex),
                DataEntry(getRPDProfitKey(rpdSyncIndex), amount),
                DataEntry(getRPDSnapshotContractBalanceKey(rpdSyncIndex, bondAssetId), getRPDContractBalance(bondAssetId))
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(rpdContract), amount, neutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func registrationLeaseTx(amount: Int, fee: Int, timestamp: Int) = {
    let txBytes = base64'CAIA' + fromBase58String(toString(this)) + fromBase58String(nodeAddress) + toBytes(amount) + toBytes(fee) + toBytes(timestamp)
    let balance = reserve*LEASINGSHARE/100
    let txHashBytes = blake2b256(txBytes)
    let txHash = toBase58String(txHashBytes)
    
    if(timestamp < lastBlock.timestamp || timestamp > lastBlock.timestamp + 18000) 
        then throw("invalid timestamp")
    else if(leaseTxHash != "" && (isInt(transactionHeightById(fromBase58String(leaseTxHash))) || height <= leaseTxExpireSendBlock))
        then throw("leasing not canceled")
    else if(fee > 1000000)
        then throw("invalid fee")
    else if(amount != balance || amount == 0)
        then throw("invalid amount")
    else {
        WriteSet([
            DataEntry(LeaseTxKey, txHash),
            DataEntry(LeasingAmountKey, balance),
            DataEntry(LeaseTxExpireSendBlockKey, height + 30),
            DataEntry(LeasingExpireBlockKey, height + leasingInterval)
        ])
    }
}

@Callable(i)
func registrationUnleaseTx(chainIdBase64: String, fee: Int, timestamp: Int) = {
    let txBytes = base64'CQI=' + fromBase64String(chainIdBase64) + fromBase58String(toString(this)) + toBytes(fee) + toBytes(timestamp) +  fromBase58String(leaseTxHash)
    let txHash = blake2b256(txBytes)

    if(!isInt(transactionHeightById(txHash)))
        then throw("blockchain does not contain this transaction")
    else if(fee > 500000)
        then throw("invalid fee")
    else {
        WriteSet([
            DataEntry(LeaseTxKey, ""),
            DataEntry(LeasingAmountKey, 0),
            DataEntry(LeaseTxExpireSendBlockKey, 0),
            DataEntry(LeasingExpireBlockKey, 0)
        ])
    }
}

@Verifier(tx)
func verify() = {
    match tx {
        case leaseTx: LeaseTransaction =>
            fromBase58String(leaseTxHash) == leaseTx.id && height <= leasingExpireBlock && height <= leaseTxExpireSendBlock
        case unleaseTx: LeaseCancelTransaction =>
            fromBase58String(leaseTxHash) == unleaseTx.leaseId && height > leasingExpireBlock
        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey) && (height <= scriptUpdateBlock || isRebalance)
    }
}