{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#
# Smart Contract Implementing Staking and Reward Withdrawal by Users of Neutrino Protocol
# (RPD is Reward Payouts Distribution)
#

# base function
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
#end base function

# consts
let LISTSPLITSYMBOL = "_"
let PERCENTACCURACY = 10000
# end consts

#constructor
let NeutrinoAssetIdKey = "neutrino_asset_id"
let NeutrinoContractKey = "neutrino_contract"
#end constructor

# keys
let BalanceKey = "rpd_balance"

func getUserBalanceKey(owner: String, assetId: String) = BalanceKey + "_" + assetId + "_" + owner
func getContractBalanceKey(assetId: String) = BalanceKey + "_" + assetId
#end keys

#global vars
let neutrinoContract = getStringByKey(NeutrinoContractKey)
# Neutrino asset id
# this value is from neutrino.ride
let neutrinoAssetId = fromBase58String(getStringByAddressAndKey(neutrinoContract, NeutrinoAssetIdKey))
#end global vars

# get func

func getContractBalance(assetId: String) = getNumberByKey(getContractBalanceKey(assetId))
func getUserBalance(owner : String, assetId: String) = getNumberByKey(getUserBalanceKey(owner, assetId))
#end get func

# start neutrino staking
# [called by user]
@Callable(i)
func lockNeutrino() = {
    let pmt = extract(i.payment)
    if (pmt.assetId != neutrinoAssetId)
        then throw("can use neutrino")
    else {
        let account = toString(i.caller)
        let assetIdString = toBase58String(value(pmt.assetId))

        WriteSet([
            DataEntry(getContractBalanceKey(assetIdString), getContractBalance(assetIdString) + pmt.amount),
            DataEntry(getUserBalanceKey(account, assetIdString), getUserBalance(account, assetIdString) + pmt.amount)
        ])
    }
}

# cancel neutrino staking
# [called by user]
@Callable(i)
func unlockNeutrino(unlockAmount: Int, assetIdString: String) = {
    let account = toString(i.caller)
    let assetId = fromBase58String(assetIdString)
    let balance = getUserBalance(account, assetIdString) - unlockAmount
    if (balance < 0)
        then throw("invalid amount")
    else if(assetId != neutrinoAssetId)
        then throw("can use neutrino")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(getContractBalanceKey(assetIdString), getContractBalance(assetIdString) - unlockAmount),
                DataEntry(getUserBalanceKey(account, assetIdString), balance)
            ]),
            TransferSet([ScriptTransfer(addressFromStringValue(account), unlockAmount, neutrinoAssetId)])
        )
    }
}