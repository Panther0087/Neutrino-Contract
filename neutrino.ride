{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}

func getNumberByKeyAndAddress(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKeyAndAddress(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKeyAndAddress(address: String, key: String) = {
    match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#end base function

let ListSplitSymbol = "_"
let SnapshotBlockExpire = 10
let BalanceLockBlock = 2
let ListDataSplitSymbol = "+"
let Wavelet = 100000000
let MinimalBondOrder = 10 * Wavelet
let MinimalSurplus = 10 * Wavelet
let ApplyBlockTimeout = 10

# data store function
let LeaseContractKey = "lease_contract"
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let PriceKey = "price"
let NeutrinoSupplyKey = "neutrino_supply"
let WavesReserveKey = "waves_reserve"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderbookTotalKey = "orderbook_total"
let OrderbookTotalSnapshotKey = "orderbook_total_snapshot"
let SurplusKey = "surplus"
let SnapshotBlockKey = "snapshot_block"
let OrderbookSnapshotKey = "orderbook_snapshot"
let BondGeneratedBlockKey = "bond_generated_block"
let AccountSnapshotBlockKey = "account_snapshot_block_"
let AccountSnapshotOwnerKey = "account_snapshot_owner_"
let AccountSnapshotAmountKey = "account_snapshot_amount_"
let AccountSnapshotNodeKey = "account_snapshot_node_"
let SnapshotNodeBalanceKey = "snapshot_node_balance_" 
let NodeBalanceKey = "node_balance_"
let IsSentNodeBalanceKey = "is_sent_node_balance_"
let NodeProviderStatus = "node_status"

let price = getNumberByKey(PriceKey)
let reserve = getNumberByKey(WavesReserveKey)
let neutrinoSupply = getNumberByKey(NeutrinoSupplyKey)
let orderbookTotal = getNumberByKey(OrderbookTotalKey)
let orderbook = getStringByKey(OrderbookKey)
let surplus = getNumberByKey(SurplusKey)
let snapshotBlock = getNumberByKey(SnapshotBlockKey)
let lastBondGenerated = getNumberByKey(BondGeneratedBlockKey)
let orderbookSnapshot = getStringByKey(OrderbookSnapshotKey)
let orderbookTotalSnapshot = getNumberByKey(OrderbookTotalSnapshotKey)
let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let auctionContract = getStringByKey(AuctionContractKey)
let leaseContract = getStringByKey(LeaseContractKey)
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}

func getWavesBalance(owner : String) = getNumberByKey(WavesBalanceKey + owner)
func getNeutrinoBalance(owner : String) = getNumberByKey(NeutrinoBalanceKey + owner)
func getBalanceBlock(owner : String) = getNumberByKey(BalanceBlockKey + owner)
func getOrderTotal(id : String) = getNumberByKey(OrderTotalKey + id)
func getOrderOwner(id : String) = getStringByKey(OrderOwnerKey + id)
func getAccountSnapshotBlock(id : String) = getNumberByKey(AccountSnapshotBlockKey + id)
func getAccountSnapshotOwner(id : String) = getStringByKey(AccountSnapshotOwnerKey + id)
func getAccountSnapshotAmount(id : String) = getNumberByKey(AccountSnapshotAmountKey + id)
func getNodeBalance(address: String, block: Int) = getNumberByKeyAndAddress(leaseContract, NodeBalanceKey + address + ListSplitSymbol + toString(block))
func isSentNodeBalance(address: String, block: Int) = getBoolByKey(IsSentNodeBalanceKey + address + ListSplitSymbol + toString(block))

#end data store function

func convertNeutrinoToWaves(amount: Int) = {
    amount*100/price 
}
func convertWavesToNeutrino(amount: Int) = {
    amount*price/100 
}
func convertNeutrinoToBond(amount: Int) = {
    amount/Wavelet 
}
func convertBondToNeutrino(amount: Int) = {
    amount*Wavelet 
}
func convertWavesToBond(amount: Int) = {
    convertNeutrinoToBond(convertWavesToNeutrino(amount))
}

@Callable(i)
func setCurrentPrice(price : Int) = {
    WriteSet([
        DataEntry(PriceKey, price),
        DataEntry(PriceKey + ListSplitSymbol + toString(height), price)
    ])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertWavesToNeutrino(pmt.amount)
        WriteSet([
            DataEntry(NeutrinoBalanceKey + toString(i.caller), amount + getNeutrinoBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height),
            DataEntry(WavesReserveKey, reserve + pmt.amount),
            DataEntry(NeutrinoSupplyKey, neutrinoSupply + amount)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let pmt = extract(i.payment)
    if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertNeutrinoToWaves(pmt.amount)
        WriteSet([
            DataEntry(WavesBalanceKey + toString(i.caller), amount + getWavesBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height),
            DataEntry(WavesReserveKey, reserve - amount),
            DataEntry(NeutrinoSupplyKey, neutrinoSupply - pmt.amount)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getBalanceBlock(account) + BalanceLockBlock > height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(WavesBalanceKey + account, 0),
                DataEntry(NeutrinoBalanceKey + account, 0)
            ]),
            TransferSet([
                ScriptTransfer(i.caller, getNeutrinoBalance(account), neutrinoAssetId),
                ScriptTransfer(i.caller,  getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)
    if(deficit >= MinimalBondOrder && height > lastBondGenerated + SnapshotBlockExpire) then
        ScriptResult(
            WriteSet([DataEntry(BondGeneratedBlockKey, height)]),
            TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), convertNeutrinoToBond(deficit), bondAssetId)])
        )
    else throw("deficit did not reach the threshold. deficit =" + toString(deficit))
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookTotalKey, orderbookTotal + pmt.amount),
            DataEntry(OrderbookKey, orderbook + newOrderId + ListSplitSymbol),

            DataEntry(OrderTotalKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let total = getOrderTotal(orderId)

    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let newOrderBookOnePart = orderbook.split(orderId + ListSplitSymbol)[0]
        let newOrderBookTwoPart = orderbook.split(orderId + ListSplitSymbol)[1]

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookTotalKey, orderbookTotal - total),
                DataEntry(OrderbookKey, newOrderBookOnePart + newOrderBookTwoPart),

                DataEntry(OrderTotalKey + orderId, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, total, unit)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderId = orderbookSnapshot.split(ListSplitSymbol)[0]
    let orderTotal = getOrderTotal(orderId)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else {
        let parts = orderbook.split(orderId + ListSplitSymbol)
        let newActualOrderbook = parts[0] + parts[1]
    
        let amount = convertBondToNeutrino(orderTotal - convertNeutrinoToBond(surplus))

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookTotalKey, orderbookTotal - (if(surplus >= orderTotal) then orderTotal else surplus)),

                DataEntry(OrderbookKey, newActualOrderbook),
                DataEntry(OrderbookSnapshotKey, orderbookSnapshot.split(orderId + ListSplitSymbol)[1]),
                DataEntry(OrderTotalKey + orderId, if (amount <= 0) then 0 else amount)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, (if(surplus >= orderTotal) then convertBondToNeutrino(orderTotal) else surplus), neutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func createSnapshot() = {
    let newSurplus = convertWavesToNeutrino(reserve) - neutrinoSupply
    
    if(newSurplus <= 0 || newSurplus < MinimalSurplus) 
        then throw("surplus is less minimum")
    else if(height >= snapshotBlock + SnapshotBlockExpire) then {
        WriteSet([
            DataEntry(OrderbookSnapshotKey, orderbook),
            DataEntry(OrderbookTotalSnapshotKey, orderbookTotal),
            DataEntry(SnapshotBlockKey, height),
            DataEntry(SurplusKey, surplus)
        ])
    } else throw("error create new snapshot")
}

@Callable(i)
func snapshotNeutrino(address : String) = {
    let owner = addressFromStringValue(address)
    let userNeutrinoBalance = assetBalance(owner, neutrinoAssetId)
    let userBondBalance = assetBalance(owner, bondAssetId)
    let amount = userBondBalance + userNeutrinoBalance
    let id = toBase58String(keccak256(toBytes(amount) + owner.bytes + toBytes(height)));

    if(getAccountSnapshotOwner(id) != "")
        then throw("id exists")
    else {
        WriteSet([
            DataEntry(AccountSnapshotAmountKey + id, amount),
            DataEntry(AccountSnapshotBlockKey + id, height),
            DataEntry(AccountSnapshotOwnerKey + id, toString(i.caller))
        ])
    }
}

#new snapshot logic
@Callable(i)
func getNewNeutrino(id : String) = {
    let userNeutrinoBalance = assetBalance(i.caller, neutrinoAssetId)
    let userBondBalance = assetBalance(i.caller, bondAssetId)

    let allowBond = bondSupply - orderbookTotalSnapshot

    let balanceSurplus = surplus - convertBondToNeutrino(orderbookTotalSnapshot)

    let block = getAccountSnapshotBlock(id)
    let amount = getAccountSnapshotAmount(id)

    if(balanceSurplus <= 0) 
        then throw("surplus is less than zero")
    else if(block > snapshotBlock)
        then throw("wait new snapshot")
    else if(userBondBalance + userNeutrinoBalance < amount)
        then throw("invalid balance snapshot")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(AccountSnapshotAmountKey + id, 0),
                DataEntry(AccountSnapshotBlockKey + id, 0)
            ]), 
            TransferSet([ #TODO
                ScriptTransfer(i.caller, balanceSurplus*(amount*100/(neutrinoSupply + allowBond))/100, neutrinoAssetId)
            ])
        )
    }
}

#LeaseContract

@Callable(i)
func sendToLeasing(nodeProvider : String, block : Int) = {
    let nodeAmount = getNodeBalance(nodeProvider, block)
    
    if (isSentNodeBalance(nodeProvider, block) == true)
        then throw("funds were sent")
    else if (height > block + ApplyBlockTimeout) # applyBlockTime fix
        then throw("apply setting time expire (" + toString(block + ApplyBlockTimeout) + ")")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(IsSentNodeBalanceKey + nodeProvider + ListSplitSymbol + toString(block) , true)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(nodeProvider), nodeAmount, unit)
            ])
        )
    }
}