{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

let NONE = "none"

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStrByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
}

#end base function

# data store function

let AccountBalanceKey = "balance_"
let NeutrinoPriceKey = "nusd_price"
let BondCountKey = "bond_count"
let BondPriceKey = "bond_price"
let BondBlockKey = "bond_block"
let BondOwnerKey = "bond_owner"
let BondStatus = "bond_status"


func getAccountBalanceKey(account : String) = {
    AccountBalanceKey + account
}

func getAccountBalance(account : String) = {
    getNumberByKey(getAccountBalanceKey(account))
}
func getNeutrinoPrice() = {
    getNumberByKey(NeutrinoPriceKey)
}
func getBondCount() = {
    getNumberByKey(BondCountKey)
}

func getBondPrice() = {
    getNumberByKey(BondPriceKey)
}
func getBondStatus() = {
    getNumberByKey(BondPriceKey)
}
func getBondOrderBlock() = {
    getNumberByKey(BondBlockKey)
}
func getBondOwner() = {
    getStrByKey(BondOwnerKey)
}


#end data store function
let Wavelet = 100000000
let ExpireBondOrder = 10
let ExcecutedStatus = "excecuted"
let NeutrinoAssetIdString = ""
let NeutrinoAssetId = toBytes(NeutrinoAssetIdString)
let BondAssetIdString = ""
let BondAssetId = toBytes(NeutrinoAssetIdString)
let NeutrinoName = "Neutrino-USD"
let NeutrinoSymbol = "N-USD"
let MinimalBondOrder = 10*Wavelet

func getSupply() = {
    assetBalance(this, NeutrinoAssetId)
}

func getReserve() = {
    wavesBalance(this)
}

@Callable(i)
func swapWavesToNeutrino() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only at the moment")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount*price
        
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId == NeutrinoAssetId) 
        then throw("can use neutrino only at the moment")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}

@Callable(i)
func setBondOrder(price: Int) = {
    let priceNeutrino = getNeutrinoPrice()
    let reserve = getReserve()
    let supply = getSupply()
    let deficit = supply/priceNeutrino - reserve
    let pmt = extract(i.payment) 
    let boudBlock = getBondOrderBlock()
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only at the moment")
    else if(deficit == pmt.amount)
        then throw("amount does not cover deficit")
    else if(boudBlock == 0) then {
        if(deficit < MinimalBondOrder)
            then throw("bond not generated")
        else {
            let amount = pmt.amount/price
            ScriptResult(
                WriteSet([
                    DataEntry(BondBlockKey, height),
                    DataEntry(BondPriceKey, price),
                    DataEntry(BondOwnerKey, toString(i.caller)),
                    DataEntry(BondCountKey, pmt.amount/price)
                ]),
                TransferSet([
                    ScriptTransfer(i.caller, amount, NeutrinoAssetId)
                ])
            )
        }
    }
    else if(boudBlock + ExpireBondOrder > height) #TODO
        then throw("TODO")
    else {
        let lastPrice = getBondPrice()
        let lastCount = getBondCount()

        if(lastPrice >= price)
            then throw("bond not generated")
        else {
            ScriptResult(
                WriteSet([
                    DataEntry(BondPriceKey, price),
                    DataEntry(BondOwnerKey, toString(i.caller)),
                    DataEntry(BondCountKey, pmt.amount/price)
                ]),
                TransferSet([
                    ScriptTransfer(addressFromStringValue(getBondOwner()), lastCount*lastPrice, NeutrinoAssetId)
                ])
            )
        }
    }
}

