{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

let NONE = "none"

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStrByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
}

#end base function

# data store function
let AccountBalanceKey = "balance_"
let NeutrinoPriceKey = "nusd_Price"
let BoundCountKey = "bound_count"
let BoundPriceKey = "bound_price"
let BoundStatus = "bound_status"


func getAccountBalanceKey(account : String) = {
    AccountBalanceKey + account
}

func getAccountBalance(account : String) = {
    getNumberByKey(getAccountBalanceKey(account))
}
func getNeutrinoPrice() = {
    getNumberByKey(NeutrinoPriceKey)
}
func getBoundCount() = {
    getNumberByKey(BoundCountKey)
}

func getBoundPrice() = {
    getNumberByKey(BoundPriceKey)
}
func getBoundStatus() = {
    getNumberByKey(BoundPriceKey)
}
#end data store function

let ExpireBoundOrder = 10
let ExcecutedStatus = "excecuted"
let NeutrinoAssetIdString = ""
let NeutrinoAssetId = toBytes(NeutrinoAssetIdString)
let BondAssetIdString = ""
let BondAssetId = toBytes(NeutrinoAssetIdString)
let NeutrinoName = "Neutrino-USD"
let NeutrinoSymbol = "N-USD"
let MinimalBondOrder = 10

func getSupply() = {
    assetBalance(this, NeutrinoAssetId)
}

func getReserve() = {
    wavesBalance(this)
}

@Callable(i)
func swapWavesToNeutrino() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only at the moment")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount*price
        
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId == NeutrinoAssetId) 
        then throw("can use neutrino only at the moment")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}

@Callable(i)
func setBondOrder(price: Int) = {
    let priceNeutrino = getNeutrinoPrice()
    let reserv = getReserve()
    let supply = getSupply()
    
    if(supply/priceNeutrino - reserv < MinimalBondOrder)
        then throw("bound not generated")
    else {
        let pmt = extract(i.payment)  
        if (isDefined(pmt.assetId)) 
            then throw("can use waves only at the moment")
        else{
            let account = toBase58String(i.caller.bytes)
            let amount = pmt.amount/price
            TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
        }
    }
}

@Callable(i)
func withdrawBond() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId == NeutrinoAssetId) 
        then throw("can use neutrino only at the moment")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}
