{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

let NONE = ""

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
}

#end base function

# data store function
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"

let AuctionContractKey = "auction_contract"

let PriceKey = "price"

let OrderBookKey = "orderbook"
let OrderAmountKey = "order_amount_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderBookAmountKey = "orderbook_amount"
let OrderBookAmountSnapshotKey = "orderbook_amount_key"

let SurplusKey = "surplus_amount"
let SurplusBlockKey = "surplus_block"
let OrderbookSnapshotKey = "orderbook_snapshot"
let OrderbookSnapshotBlockKey = "orderbook_snapshot_block"
let BondGeneratedBlockKey = "bond_generated_block"

let LockNeutrinoBlockKey = "lock_block_"
let LockNeutrinoOwnerKey = "lock_owner_"
let LockNeutrinoAmountKey = "lock_amount_"

func getPrice() = {
    getNumberByKey(PriceKey)
}

func getOrderBook() = {
    getStringByKey(OrderBookKey)
}
func getOrderBookAmount() = {
    getNumberByKey(OrderBookAmountKey)
}
func getOrderAmount(id : String) = {
    getNumberByKey(OrderAmountKey + id)
}
func getOrderOwner(id : String) = {
    getStringByKey(OrderOwnerKey + id)
}

func getSurplus() = {
    getStringByKey(SurplusKey)
}
func getSurplusBlock() = {
    getNumberByKey(SurplusKey)
}
func getBondGeneratedBlock() = {
    getNumberByKey(BondGeneratedBlockKey)
}
func getOrderbookSnapshot() = {
    getStringByKey(OrderbookSnapshotKey)
}
func getOrderBookAmountSnapshot() = {
    getNumberByKey(OrderBookAmountSnapshotKey)
}
func getOrderbookSnapshotBlock() = {
    getNumberByKey(OrderbookSnapshotBlockKey)
}

func getLockNeutrinoBlock(id : String) = {
    getNumberByKey(LockNeutrinoBlockKey + id)
}
func getLockNeutrinoOwner(id : String) = {
    getStringByKey(LockNeutrinoOwnerKey + id)
}
func getLockNeutrinoAmount(id : String) = {
    getNumberByKey(LockNeutrinoAmountKey + id)
}

#end data store function

let SnapshotBlockExpire = 10
let OrderSplitSymbol = "_"
let Wavelet = 100000000
let MinimalBondOrder = 10
let MinimalSurplus = 10
let NeutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let BondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let AuctionContract = getStringByKey(AuctionContractKey)

func getReserve() = {
    wavesBalance(this)
}
func getNeutrinoSupply() = {
    let info = extract(assetInfo(NeutrinoAssetId))
    info.quantity - assetBalance(this, NeutrinoAssetId)
}
func getBondSupply() = {
    let info = extract(assetInfo(BondAssetId))
    info.quantity - assetBalance(this, BondAssetId)
}


@Callable(i)
func setCurrentPrice(price : Int) = {
    WriteSet([DataEntry(PriceKey, price)])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let price = getPrice()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount*price
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let price = getPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId != NeutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price
        TransferSet([ScriptTransfer(addressFromStringValue(account), amount, unit)])
    }
}

@Callable(i)
func generateBond() = {
    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supply = getNeutrinoSupply()
    let deficit = supply - reserve*priceNeutrino
    let lastBondGenerated = getBondGeneratedBlock()
    if(deficit >= MinimalBondOrder && lastBondGenerated + SnapshotBlockExpire > height) 
        then ScriptResult(
            WriteSet([DataEntry(BondGeneratedBlockKey, height)]),
            TransferSet([ScriptTransfer(addressFromStringValue(AuctionContract), deficit - MinimalBondOrder, BondAssetId)])
        )
    else throw("deficit did not reach the threshold")
}

@Callable(i)
func setOrder() = {
    let orderbook = getOrderBook();
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != BondAssetId) 
        then throw("can use waves only")
    else if(getOrderOwner(newOrderId) != NONE)
        then throw("order exists")
    else if(orderbook == NONE) 
        then WriteSet([
            DataEntry(OrderBookAmountKey, getOrderBookAmount() + pmt.amount),
            DataEntry(OrderBookKey, OrderSplitSymbol + newOrderId),

            DataEntry(OrderAmountKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height)
        ])
    else {
        WriteSet([
            DataEntry(OrderBookAmountKey, getOrderBookAmount() + pmt.amount),
            DataEntry(OrderBookKey, orderbook + OrderSplitSymbol + newOrderId),

            DataEntry(OrderAmountKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let orderbook = getOrderBook();
    let owner = getOrderOwner(orderId)
    let amount = getOrderAmount(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let newOrderBookOnePart = orderbook.split(OrderSplitSymbol + orderId)[0]
        let newOrderBookTwoPart = orderbook.split(OrderSplitSymbol + orderId)[1]

        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountKey, getOrderBookAmount() - amount),
                DataEntry(OrderBookKey, newOrderBookOnePart + newOrderBookTwoPart),

                DataEntry(OrderAmountKey + orderId, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, unit)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderbook = getOrderbookSnapshot();
    let orderId = orderbook.split(OrderSplitSymbol)[1]
    let orderAmount = getOrderAmount(orderId)
    
    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supply = getNeutrinoSupply()
    let surplus = reserve*priceNeutrino - supply
    
    if(orderAmount == 0) then {
        let newOrderBookTwoPart = orderbook.split(orderId + OrderSplitSymbol)[1]
        ScriptResult(
            WriteSet([
                DataEntry(OrderbookSnapshotKey, newOrderBookTwoPart)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, orderAmount, NeutrinoAssetId)
            ])
        )
    }
    else if(surplus <= 0) 
        then throw("surplus is less than zero")
    else if(surplus >= orderAmount) then {
        let newOrderbookSnapshot = orderbook.split(orderId + OrderSplitSymbol)[1]
        let actualOrderbook = getOrderBook()

        let newActualOrderBookOnePart = actualOrderbook.split(OrderSplitSymbol + orderId)[0]
        let newActualOrderBookTwoPart = actualOrderbook.split(OrderSplitSymbol + orderId)[1]
        
        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountKey, getOrderBookAmount() - orderAmount),

                DataEntry(OrderBookKey, newActualOrderBookOnePart + newActualOrderBookTwoPart),
                DataEntry(OrderbookSnapshotKey, newOrderbookSnapshot),
                DataEntry(OrderAmountKey + orderId, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, orderAmount, NeutrinoAssetId)
            ])
        )
    }
    else {
        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountKey, getOrderBookAmount() - surplus),

                DataEntry(OrderAmountKey + orderId, orderAmount - surplus)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, surplus, NeutrinoAssetId)
            ])
        )    
    }
}

@Callable(i)
func calculateSurplusAndCreateSnapshot() = {
    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supply = getNeutrinoSupply()
    let surplus = reserve*priceNeutrino - supply
    
    if(surplus <= 0 || surplus < MinimalSurplus) 
        then throw("surplus is less minimum")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountSnapshotKey, getOrderBookAmount()),
                DataEntry(SurplusBlockKey, height),
                DataEntry(SurplusKey, surplus)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, surplus, NeutrinoAssetId)
            ])
        )   
    }
}

@Callable(i)
func snapshotNeutrino() = {
    let userNeutrinoBalance = assetBalance(i.caller, NeutrinoAssetId)
    let userBondBalance = assetBalance(i.caller, BondAssetId)
    let amount = userBondBalance + userNeutrinoBalance
    let id = toBase58String(keccak256(toBytes(amount) + i.caller.bytes + toBytes(height)));

    if(getLockNeutrinoOwner(id) != NONE)
        then throw("id exists")
    else {
        WriteSet([
            DataEntry(LockNeutrinoAmountKey + id, amount),
            DataEntry(LockNeutrinoBlockKey + id, height),
            DataEntry(LockNeutrinoOwnerKey + id, toString(i.caller))
        ])
    }
}

@Callable(i)
func getNewNeutrino(id : String) = {
    let userNeutrinoBalance = assetBalance(i.caller, NeutrinoAssetId)
    let userBondBalance = assetBalance(i.caller, BondAssetId)
    let orderbook = getOrderbookSnapshot()

    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supplyNeutrino = getNeutrinoSupply()
    let supplyBond = getBondSupply()
    let allowBond = supplyBond - getOrderBookAmountSnapshot()
    let surplus = reserve*priceNeutrino - supplyNeutrino
    let surplusBlock = getSurplusBlock()

    let block = getLockNeutrinoBlock(id)
    let amount = getLockNeutrinoAmount(id)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else if(surplusBlock <= block)
        then throw("wait new snapshot")
    else if(userBondBalance + userNeutrinoBalance != amount)
        then throw("invalid balance snapshot")
    else if(orderbook == NONE) then {
        ScriptResult(
            WriteSet([
                DataEntry(LockNeutrinoAmountKey + id, 0),
                DataEntry(LockNeutrinoBlockKey + id, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, surplus*amount/(supplyNeutrino + allowBond), NeutrinoAssetId)
            ])
        )
    }else throw("orderbook nor empty")
}
