{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

let NONE = "none"

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
}

#end base function

# data store function

let AccountBalanceKey = "balance_"
let NeutrinoPriceKey = "neutrino_price"
let BondCountKey = "bond_count"
let BondPriceKey = "bond_price"
let BondBlockKey = "bond_block"
let BondOwnerKey = "bond_owner"
let BondStatusKey = "bond_status"
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let SupplyKey = "supply"

func getAccountBalanceKey(account : String) = {
    AccountBalanceKey + account
}
func getAccountBalance(account : String) = {
    getNumberByKey(getAccountBalanceKey(account))
}
func getSupply() = {
    getNumberByKey(SupplyKey)
}
func getNeutrinoPrice() = {
    getNumberByKey(NeutrinoPriceKey)
}
func getBondCount() = {
    getNumberByKey(BondCountKey)
}
func getBondPrice() = {
    getNumberByKey(BondPriceKey)
}
func getBondStatus() = {
    getStringByKey(BondStatusKey)
}
func getBondOrderBlock() = {
    getNumberByKey(BondBlockKey)
}
func getBondOwner() = {
    getStringByKey(BondOwnerKey)
}


#end data store function
let Wavelet = 100000000
let ExpireBondOrder = 2
let EndStatus = "end"
let NewStatus = "new"
let MinimalBondOrder = 1*Wavelet
let NeutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let BondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))

func getReserve() = {
    wavesBalance(this)
}


@Callable(i)
func setCurrentPrice(price : Int) = {
    WriteSet([DataEntry(NeutrinoPriceKey, price)])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount*price
        ScriptResult(
            WriteSet([DataEntry(SupplyKey, getSupply() + amount)]),
            TransferSet([ScriptTransfer(addressFromStringValue(account), amount, NeutrinoAssetId)])
        )
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let price = getNeutrinoPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId != NeutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price
        ScriptResult(
            WriteSet([DataEntry(SupplyKey, getSupply() + pmt.amount)]),
            TransferSet([ScriptTransfer(addressFromStringValue(account), amount, unit)])
        )
    }
}

@Callable(i)
func setBondOrder(price: Int) = {
    let priceNeutrino = getNeutrinoPrice()
    let reserve = getReserve()
    let supply = getSupply()
    let deficit = supply/priceNeutrino - reserve
    let pmt = extract(i.payment) 
    let boudBlock = getBondOrderBlock()
    
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only at the moment")
    else if(deficit == pmt.amount)
        then throw("amount does not cover deficit")
    else if(boudBlock + ExpireBondOrder >= height || boudBlock == 0) then {
        if(deficit < MinimalBondOrder)
            then throw("bond not generated")
        else if(getBondOwner() == NewStatus) then
            ScriptResult(
                WriteSet([
                    DataEntry(BondBlockKey, height),
                    DataEntry(BondPriceKey, price),
                    DataEntry(BondOwnerKey, toString(i.caller)),
                    DataEntry(BondCountKey, pmt.amount/price),
                    DataEntry(BondStatusKey, NewStatus)
                ]),
                TransferSet([
                    ScriptTransfer(addressFromStringValue(getBondOwner()), getBondCount(), BondAssetId)
                ])
            )
        else
            WriteSet([
                DataEntry(BondBlockKey, height),
                DataEntry(BondPriceKey, price),
                DataEntry(BondOwnerKey, toString(i.caller)),
                DataEntry(BondCountKey, pmt.amount/price),
                DataEntry(BondStatusKey, NewStatus)
            ])
    }
    else {
        let lastPrice = getBondPrice()
        let lastCount = getBondCount()

        if(lastPrice >= price)
            then throw("bond not generated")
        else
            ScriptResult(
                WriteSet([
                    DataEntry(BondPriceKey, price),
                    DataEntry(BondOwnerKey, toString(i.caller)),
                    DataEntry(BondCountKey, pmt.amount/price)
                ]),
                TransferSet([
                    ScriptTransfer(addressFromStringValue(getBondOwner()), lastCount*lastPrice, NeutrinoAssetId)
                ])
            )
    }
}

@Callable(i)
func withdrawBond(price: Int) = {
    let boudBlock = getBondOrderBlock()
    if(boudBlock + ExpireBondOrder < height)
        then throw("auction not ended")
    else{
        ScriptResult(
            WriteSet([
                DataEntry(BondStatusKey, EndStatus)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(getBondOwner()), getBondCount(), BondAssetId)
            ])
        )
    }
}

@Callable(i)
func excecuteBond(price: Int) = { #TODO
    let pmt = extract(i.payment)
    if(pmt.assetId != BondAssetId)
        then throw("can use bond only")
    else
        TransferSet([
            ScriptTransfer(i.caller, pmt.amount, NeutrinoAssetId)
        ])
}