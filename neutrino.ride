{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}

func getNumberByKeyAndAddress(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKeyAndAddress(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKeyAndAddress(address: String, key: String) = {
    match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#end base function

let ListSplitSymbol = "_"
let BalanceLockBlock = 0
let ListDataSplitSymbol = "+"
let Wavelet = 100000000
let MinimalBondOrder = 10 * Wavelet
let MinimalSurplus = 10 * Wavelet
let ApplyBlockTimeout = 10

# data store function
let LeaseContractKey = "lease_contract"
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let PriceKey = "price"
#let NeutrinoSupplyKey = "neutrino_supply"
#let WavesReserveKey = "waves_reserve"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderFilledTotalKey = "order_filled_total_"
#let SurplusKey = "surplus"
let SnapshotBlockKey = "snapshot_block"
let OrderbookSnapshotKey = "orderbook_snapshot"
let BondGeneratedBlockKey = "bond_generated_block"
let AccountSnapshotBlockKey = "account_snapshot_block_"
let AccountSnapshotOwnerKey = "account_snapshot_owner_"
let AccountSnapshotAmountKey = "account_snapshot_amount_"
let AccountSnapshotNodeKey = "account_snapshot_node_"
let SnapshotNodeBalanceKey = "snapshot_node_balance_" 
let NodeBalanceKey = "node_balance_"
let IsSentNodeBalanceKey = "is_sent_node_balance_"
let NodeProviderStatus = "node_status"
let OrderStatusKey = "order_status_"

let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let price = getNumberByKey(PriceKey)
let reserve = wavesBalance(this)
let neutrinoSupply = {
    let info = extract(assetInfo(neutrinoAssetId))
    info.quantity - assetBalance(this, neutrinoAssetId)
}
let orderbook = getStringByKey(OrderbookKey)
let snapshotBlock = getNumberByKey(SnapshotBlockKey)
let lastBondGenerated = getNumberByKey(BondGeneratedBlockKey)
let orderbookSnapshot = getStringByKey(OrderbookSnapshotKey)
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let auctionContract = getStringByKey(AuctionContractKey)
let leaseContract = getStringByKey(LeaseContractKey)
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}

func getWavesBalance(owner : String) = getNumberByKey(WavesBalanceKey + owner)
func getNeutrinoBalance(owner : String) = getNumberByKey(NeutrinoBalanceKey + owner)
func getBalanceBlock(owner : String) = getNumberByKey(BalanceBlockKey + owner)
func getOrderTotal(id : String) = getNumberByKey(OrderTotalKey + id)
func getOrderOwner(id : String) = getStringByKey(OrderOwnerKey + id)
func getAccountSnapshotBlock(id : String) = getNumberByKey(AccountSnapshotBlockKey + id)
func getAccountSnapshotOwner(id : String) = getStringByKey(AccountSnapshotOwnerKey + id)
func getAccountSnapshotAmount(id : String) = getNumberByKey(AccountSnapshotAmountKey + id)
func getNodeBalance(address: String, block: Int) = getNumberByKeyAndAddress(leaseContract, NodeBalanceKey + address + ListSplitSymbol + toString(block))
func isSentNodeBalance(address: String, block: Int) = getBoolByKey(IsSentNodeBalanceKey + address + ListSplitSymbol + toString(block))
func getOrderFilledTotal(id : String) = getNumberByKey(OrderFilledTotalKey + id)

#end data store function

func convertNeutrinoToWaves(amount: Int) = amount*100/price 
func convertWavesToNeutrino(amount: Int) = amount*price/100 
func convertNeutrinoToBond(amount: Int) = amount/Wavelet 
func convertBondToNeutrino(amount: Int) = amount*Wavelet 
func convertWavesToBond(amount: Int) = convertNeutrinoToBond(convertWavesToNeutrino(amount))
let surplus = convertWavesToNeutrino(reserve) - neutrinoSupply

let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"

@Callable(i)
func setCurrentPrice(price : Int) = {
    WriteSet([
        DataEntry(PriceKey, price),
        DataEntry(PriceKey + ListSplitSymbol + toString(height), price)
    ])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertWavesToNeutrino(pmt.amount)
        WriteSet([
            DataEntry(NeutrinoBalanceKey + toString(i.caller), amount + getNeutrinoBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        #    DataEntry(WavesReserveKey, reserve + pmt.amount),
       #     DataEntry(NeutrinoSupplyKey, neutrinoSupply + amount)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let pmt = extract(i.payment)
    if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertNeutrinoToWaves(pmt.amount)
        WriteSet([
            DataEntry(WavesBalanceKey + toString(i.caller), amount + getWavesBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        #    DataEntry(WavesReserveKey, reserve - amount),
        #    DataEntry(NeutrinoSupplyKey, neutrinoSupply - pmt.amount)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getBalanceBlock(account) + BalanceLockBlock >= height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(WavesBalanceKey + account, 0),
                DataEntry(NeutrinoBalanceKey + account, 0)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(account), getNeutrinoBalance(account), neutrinoAssetId),
                ScriptTransfer(addressFromStringValue(account),  getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)
    let balanceAuction = assetBalance(addressFromStringValue(auctionContract), bondAssetId)
    let amount = convertNeutrinoToBond(deficit) - balanceAuction
    if(amount > 0)
        then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), amount, bondAssetId)])
        
    else throw("deficit did not reach the threshold. deficit =" + toString(deficit))
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookKey, orderbook + newOrderId + ListSplitSymbol),

            DataEntry(OrderTotalKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height),
            DataEntry(OrderStatusKey + newOrderId, NEW)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let parts = orderbook.split(orderId + ListSplitSymbol)

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, parts[0] + parts[1]),
                DataEntry(OrderStatusKey + orderId, CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, bondAssetId)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderId = orderbook.split(ListSplitSymbol)[0]
    let orderTotal = getOrderTotal(orderId)
    let orderOwner = getOrderOwner(orderId)
    let filledTotal = getOrderFilledTotal(orderId)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else {
        let amount = orderTotal-filledTotal;
        let surplusBond = convertNeutrinoToBond(surplus)
        let status = if(surplusBond >= amount) then FILLED else NEW
        let newFilledTotal = if(surplusBond >= amount) then orderTotal else surplusBond

        ScriptResult(
            WriteSet([
            #    DataEntry(OrderbookTotalKey, orderbookTotal - (if(surplusBond >= amount) then amount else surplusBond)),

                DataEntry(OrderbookKey, orderbook.split(orderId + ListSplitSymbol)[1]),
                DataEntry(OrderFilledTotalKey + orderId, filledTotal + newFilledTotal),
                DataEntry(OrderStatusKey + orderId, status)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(newFilledTotal), neutrinoAssetId)
            ])
        )
    }
}