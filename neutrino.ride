{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}

func getNumberByKeyAndAddress(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKeyAndAddress(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKeyAndAddress(address: String, key: String) = {
    match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#end base function

let LeaseContractKey = "lease_contract"
let LeaseContract = getStringByKey(LeaseContractKey)
let ListSplitSymbol = "_"

# data store function
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"

let AuctionContractKey = "auction_contract"

let PriceKey = "price"

let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceBlockKey = "balance_block_"

let OrderBookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderBookAmountKey = "orderbook_amount"
let OrderBookAmountSnapshotKey = "orderbook_amount_key"

let SurplusKey = "surplus"
let SnapshotBlockKey = "snapshot_block"
let OrderbookSnapshotKey = "orderbook_snapshot"
let BondGeneratedBlockKey = "bond_generated_block"

let AccountSnapshotBlockKey = "account_snapshot_block_"
let AccountSnapshotOwnerKey = "account_snapshot_owner_"
let AccountSnapshotAmountKey = "account_snapshot_amount_"
let AccountSnapshotNodeKey = "account_snapshot_node_"
let SnapshotNodeBalanceKey = "snapshot_node_balance_" 

let NodeBalanceKey = "node_balance_"
let IsSentNodeBalanceKey = "is_sent_node_balance_"
let NodeProviderStatus = "node_status"

func getPrice() = getNumberByKey(PriceKey)

func getWavesBalance(owner : String) = getNumberByKey(WavesBalanceKey + owner)

func getNeutrinoBalance(owner : String) = getNumberByKey(NeutrinoBalanceKey + owner)

func getBalanceBlock(owner : String) = getNumberByKey(BalanceBlockKey + owner)

func getOrderBook() = getStringByKey(OrderBookKey)

func getOrderBookAmount() = getNumberByKey(OrderBookAmountKey)

func getOrderTotal(id : String) = getNumberByKey(OrderTotalKey + id)

func getOrderOwner(id : String) = getStringByKey(OrderOwnerKey + id)

func getSurplus() = getNumberByKey(SurplusKey)

func getSnapshotBlock() = getNumberByKey(SnapshotBlockKey)

func getBondGeneratedBlock() = getNumberByKey(BondGeneratedBlockKey)

func getOrderbookSnapshot() = getStringByKey(OrderbookSnapshotKey)

func getOrderBookAmountSnapshot() = getNumberByKey(OrderBookAmountSnapshotKey)

func getAccountSnapshotBlock(id : String) = getNumberByKey(AccountSnapshotBlockKey + id)

func getAccountSnapshotOwner(id : String) = getStringByKey(AccountSnapshotOwnerKey + id)

func getAccountSnapshotAmount(id : String) = getNumberByKey(AccountSnapshotAmountKey + id)

func getNodeBalance(address: String, block: Int) = getNumberByKeyAndAddress(LeaseContract, NodeBalanceKey + address + ListSplitSymbol + toString(block))

func isSentNodeBalance(address: String, block: Int) = getBoolByKey(IsSentNodeBalanceKey + address + ListSplitSymbol + toString(block))

#end data store function

let SnapshotBlockExpire = 10
let BalanceLockBlock = 2
let ListDataSplitSymbol = "+"
let Wavelet = 100000000
let MinimalBondOrder = 10 * Wavelet
let MinimalSurplus = 10 * Wavelet
let NeutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let BondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let AuctionContract = getStringByKey(AuctionContractKey)
let ApplyBlockTimeout = 10

func getReserve() = wavesBalance(this)

func getNeutrinoSupply() = {
    let info = extract(assetInfo(NeutrinoAssetId))
    info.quantity - assetBalance(this, NeutrinoAssetId)
}
func getBondSupply() = {
    let info = extract(assetInfo(BondAssetId))
    info.quantity - assetBalance(this, BondAssetId)
}


@Callable(i)
func setCurrentPrice(price : Int) = WriteSet([DataEntry(PriceKey, price)])

@Callable(i)
func swapWavesToNeutrino() = {
    let price = getPrice()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount*price/100 + getNeutrinoBalance(account)
        WriteSet([
            DataEntry(NeutrinoBalanceKey + toString(i.caller), amount),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let price = getPrice()
    let pmt = extract(i.payment)
    if (pmt.assetId != NeutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = pmt.amount/price*100 + getWavesBalance(account)
        WriteSet([
            DataEntry(WavesBalanceKey + toString(i.caller), amount),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getBalanceBlock(account) + BalanceLockBlock > height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(WavesBalanceKey + account, 0),
                DataEntry(BalanceBlockKey + account, 0),
                DataEntry(NeutrinoBalanceKey + account, 0)
            ]),
            TransferSet([
                ScriptTransfer(i.caller, getNeutrinoBalance(account), NeutrinoAssetId),
                ScriptTransfer(i.caller,  getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supply = getNeutrinoSupply()
    let deficit = supply - reserve*priceNeutrino/100/Wavelet
    let lastBondGenerated = getBondGeneratedBlock()
    if(deficit >= MinimalBondOrder && height > lastBondGenerated + SnapshotBlockExpire) 
        then ScriptResult(
            WriteSet([DataEntry(BondGeneratedBlockKey, height)]),
            TransferSet([ScriptTransfer(addressFromStringValue(AuctionContract), deficit/Wavelet, BondAssetId)])
        )
    else throw("deficit did not reach the threshold. deficit =" + toString(deficit))
}

@Callable(i)
func setOrder() = {
    let orderbook = getOrderBook();
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != BondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderBookAmountKey, getOrderBookAmount() + pmt.amount),
            DataEntry(OrderBookKey, orderbook +  ListSplitSymbol + newOrderId),

            DataEntry(OrderTotalKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let orderbook = getOrderBook();
    let owner = getOrderOwner(orderId)
    let total = getOrderTotal(orderId)

    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let newOrderBookOnePart = orderbook.split(ListSplitSymbol + orderId)[0]
        let newOrderBookTwoPart = orderbook.split(ListSplitSymbol + orderId)[1]

        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountKey, getOrderBookAmount() - total),
                DataEntry(OrderBookKey, newOrderBookOnePart + newOrderBookTwoPart),

                DataEntry(OrderTotalKey + orderId, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, total, unit)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let snapshotOrderbook = getOrderbookSnapshot();
    let orderId = snapshotOrderbook.split(ListSplitSymbol)[1]
    let orderTotal = getOrderTotal(orderId)
    let surplus = getSurplus()

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else {
        let actualOrderbook = getOrderBook()

        let newActualOrderbook = actualOrderbook.split(ListSplitSymbol + orderId)[0] + actualOrderbook.split(ListSplitSymbol + orderId)[1]
    
        let amount = (orderTotal - surplus/Wavelet)*Wavelet

        ScriptResult(
            WriteSet([
                DataEntry(OrderBookAmountKey, getOrderBookAmount() - (if(surplus >= orderTotal) then orderTotal else surplus)),

                DataEntry(OrderBookKey, newActualOrderbook),
                DataEntry(OrderbookSnapshotKey, snapshotOrderbook.split(ListSplitSymbol + orderId)[1]),
                DataEntry(OrderTotalKey + orderId, if (amount <= 0) then 0 else amount)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, (if(surplus >= orderTotal) then orderTotal * Wavelet else surplus), NeutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func createSnapshot() = {
    let priceNeutrino = getPrice()
    let reserve = getReserve()
    let supply = getNeutrinoSupply()
    let surplus = reserve*priceNeutrino/100 - supply
    
    if(surplus <= 0 || surplus < MinimalSurplus) 
        then throw("surplus is less minimum")
    else if(height >= getSnapshotBlock() + SnapshotBlockExpire) then {
        WriteSet([
            DataEntry(OrderbookSnapshotKey, getOrderBook()),
            DataEntry(OrderBookAmountSnapshotKey, getOrderBookAmount()),
            DataEntry(SnapshotBlockKey, height),
            DataEntry(SurplusKey, surplus)
        ])
    } else throw("error create new snapshot")
}

@Callable(i)
func snapshotNeutrino(address : String) = {
    let owner = addressFromStringValue(address)
    let userNeutrinoBalance = assetBalance(owner, NeutrinoAssetId)
    let userBondBalance = assetBalance(owner, BondAssetId)
    let amount = userBondBalance + userNeutrinoBalance
    let id = toBase58String(keccak256(toBytes(amount) + owner.bytes + toBytes(height)));

    if(getAccountSnapshotOwner(id) != "")
        then throw("id exists")
    else {
        WriteSet([
            DataEntry(AccountSnapshotAmountKey + id, amount),
            DataEntry(AccountSnapshotBlockKey + id, height),
            DataEntry(AccountSnapshotOwnerKey + id, toString(i.caller))
        ])
    }
}

@Callable(i)
func getNewNeutrino(id : String) = {
    let userNeutrinoBalance = assetBalance(i.caller, NeutrinoAssetId)
    let userBondBalance = assetBalance(i.caller, BondAssetId)
    let orderbook = getOrderbookSnapshot()

    let priceNeutrino = getPrice()
    let supplyNeutrino = getNeutrinoSupply()
    let supplyBond = getBondSupply()
    let orderbookAmount = getOrderBookAmountSnapshot()

    let allowBond = supplyBond - getOrderBookAmountSnapshot()

    let surplus = getSurplus() - orderbookAmount*Wavelet
    let snapshotBlock = getSnapshotBlock()

    let block = getAccountSnapshotBlock(id)
    let amount = getAccountSnapshotAmount(id)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else if(block > snapshotBlock)
        then throw("wait new snapshot")
    else if(userBondBalance + userNeutrinoBalance < amount)
        then throw("invalid balance snapshot")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(AccountSnapshotAmountKey + id, 0),
                DataEntry(AccountSnapshotBlockKey + id, 0)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, surplus*(amount*100/(supplyNeutrino + allowBond))/100, NeutrinoAssetId)
            ])
        )
    }
}
#LeaseContract

@Callable(i)
func sendToLeasing(nodeProvider : String, block : Int) = {
    let nodeAmount = getNodeBalance(nodeProvider, block)
    
    if (isSentNodeBalance(nodeProvider, block) == true)
        then throw("funds were sent")
    else if (height > block + ApplyBlockTimeout)
        then throw("apply setting time expire (" + toString(block + ApplyBlockTimeout) + ")")
    else {
        ScriptResult(
            WriteSet([
                DataEntry(IsSentNodeBalanceKey + nodeProvider + ListSplitSymbol + toString(block) , true)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(nodeProvider), nodeAmount, unit)
            ])
        )
    }
}