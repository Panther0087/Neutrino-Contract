{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}

func getNumberByKeyAndAddress(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKeyAndAddress(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKeyAndAddress(address: String, key: String) = {
    match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#end base function

let ListSplitSymbol = "_"
let BalanceLockBlock = 0
let ListDataSplitSymbol = "+"
let Wavelet = 100000000
let MinimalBondOrder = 10 * Wavelet
let MinimalSurplus = 10 * Wavelet
let ApplyBlockTimeout = 10

# data store function
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let PriceKey = "price"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderFilledTotalKey = "order_filled_total_"
let OrderStatusKey = "order_status_"
let OracleKey = "oracle"

let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let auctionContract = getStringByKey(AuctionContractKey)
let price = getNumberByKey(PriceKey)
let reserve = wavesBalance(this)
let orderbook = getStringByKey(OrderbookKey)
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let oracle = getStringByKey(OracleKey)
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}
let neutrinoSupply = {
    let info = extract(assetInfo(neutrinoAssetId))
    info.quantity - assetBalance(this, neutrinoAssetId)
}

func getWavesBalance(owner : String) = getNumberByKey(WavesBalanceKey + owner)
func getNeutrinoBalance(owner : String) = getNumberByKey(NeutrinoBalanceKey + owner)
func getBalanceBlock(owner : String) = getNumberByKey(BalanceBlockKey + owner)
func getOrderTotal(id : String) = getNumberByKey(OrderTotalKey + id)
func getOrderOwner(id : String) = getStringByKey(OrderOwnerKey + id)
func getOrderFilledTotal(id : String) = getNumberByKey(OrderFilledTotalKey + id)
#end data store function

func convertNeutrinoToWaves(amount: Int) = amount*100/price 
func convertWavesToNeutrino(amount: Int) = amount*price/100 
func convertNeutrinoToBond(amount: Int) = amount/Wavelet 
func convertBondToNeutrino(amount: Int) = amount*Wavelet 
func convertWavesToBond(amount: Int) = convertNeutrinoToBond(convertWavesToNeutrino(amount))
let surplus = convertWavesToNeutrino(reserve) - neutrinoSupply

let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"

@Callable(i)
func setCurrentPrice(price : Int) = {
    let account = toString(i.caller)
    if(account != oracle)
        then throw("permission denied")
    else 
        WriteSet([
            DataEntry(PriceKey, price),
            DataEntry(PriceKey + ListSplitSymbol + toString(height), price)
        ])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertWavesToNeutrino(pmt.amount)
        WriteSet([
            DataEntry(NeutrinoBalanceKey + toString(i.caller), amount + getNeutrinoBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let pmt = extract(i.payment)
    if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertNeutrinoToWaves(pmt.amount)
        WriteSet([
            DataEntry(WavesBalanceKey + toString(i.caller), amount + getWavesBalance(account)),
            DataEntry(BalanceBlockKey + toString(i.caller), height)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getBalanceBlock(account) + BalanceLockBlock >= height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(WavesBalanceKey + account, 0),
                DataEntry(NeutrinoBalanceKey + account, 0)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(account), getNeutrinoBalance(account), neutrinoAssetId),
                ScriptTransfer(addressFromStringValue(account),  getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)
    let balanceAuction = assetBalance(addressFromStringValue(auctionContract), bondAssetId)
    let amount = convertNeutrinoToBond(deficit) - balanceAuction
    if(amount > 0)
        then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), amount, bondAssetId)])
    else throw("bond were generated or do not need it")
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookKey, orderbook + newOrderId + ListSplitSymbol),

            DataEntry(OrderTotalKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height),
            DataEntry(OrderStatusKey + newOrderId, NEW)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let parts = orderbook.split(orderId + ListSplitSymbol)

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, parts[0] + parts[1]),
                DataEntry(OrderStatusKey + orderId, CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, bondAssetId)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let orderId = orderbook.split(ListSplitSymbol)[0]
    let orderTotal = getOrderTotal(orderId)
    let orderOwner = getOrderOwner(orderId)
    let filledTotal = getOrderFilledTotal(orderId)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else {
        let amount = orderTotal-filledTotal;
        let surplusBond = convertNeutrinoToBond(surplus)
        let status = if(surplusBond >= amount) then FILLED else NEW
        let newFilledTotal = if(surplusBond >= amount) then orderTotal else surplusBond

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, orderbook.split(orderId + ListSplitSymbol)[1]),
                DataEntry(OrderFilledTotalKey + orderId, filledTotal + newFilledTotal),
                DataEntry(OrderStatusKey + orderId, status)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(newFilledTotal), neutrinoAssetId)
            ])
        )
    }
}