{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByKeyAndAddress(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKeyAndAddress(address: String, key: String) = {
    match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKeyAndAddress(address: String, key: String) = {
    match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#end base function

let ListSplitSymbol = "_"
let ListDataSplitSymbol = "+"
let Wavelet = 100000000
let PercentPriceOffset = 10
let ADMINONE = ""
let ADMINTWO = ""
let ADMINTHREE = ""

# data store function

let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let RPDContractKey = "rpd_contract"
let PriceKey = "price"
let NeutrinoBalanceKey = "neutrino_"
let WavesBalanceKey = "waves_"
let BalanceUnlockBlockKey = "balance_block_"
let OrderbookKey = "orderbook"
let OrderTotalKey = "order_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderFilledTotalKey = "order_filled_total_"
let OrderStatusKey = "order_status_"
let OracleKey = "oracle"
let RPDCountKey = "rpd_count"
let RPDProfitKey = "rpd_profit"
let BalanceLockIntervalKey = "balance_lock_interval"
let IsBlockedKey = "is_blocked"
let BlackSwarmPriceKey = "black_swarm"
let AdminVoteKey = "admin_vote_"
let AdminVotePriceKey = "admin_vote_price_"
let BlockExpireVoteKey = "vote_expire_block"
let VoteIntervalKey = "vote_interval"

func getRPDProfitKey(count: Int) = RPDProfitKey + "_" + toString(count)
let rpdCount = getNumberByKey(RPDCountKey)
let voteInterval = getNumberByKey(VoteIntervalKey)
let blockExpireVote = getNumberByKey(BlockExpireVoteKey)
let balanceLockBlock = getNumberByKey(BalanceLockIntervalKey)
let isBlocked = getBoolByKey(IsBlockedKey)

let neutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let auctionContract = getStringByKey(AuctionContractKey)
let rpdContract = getStringByKey(RPDContractKey)
let price = getNumberByKey(PriceKey)
let reserve = wavesBalance(this)
let orderbook = getStringByKey(OrderbookKey)
let bondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let oracle = getStringByKey(OracleKey)
let bondSupply = {
    let info = extract(assetInfo(bondAssetId))
    info.quantity - assetBalance(this, bondAssetId)
}
let neutrinoSupply = {
    let info = extract(assetInfo(neutrinoAssetId))
    info.quantity - assetBalance(this, neutrinoAssetId)
}

func getAdminVoteInt(owner: String) = if(getBoolByKey(AdminVoteKey + owner)) then 1 else 0
func getAdminVotePrice(owner: String) = getNumberByKey(AdminVotePriceKey + owner)
func getWavesBalance(owner : String) = getNumberByKey(WavesBalanceKey + owner)
func getNeutrinoBalance(owner : String) = getNumberByKey(NeutrinoBalanceKey + owner)
func getBalanceBlock(owner : String) = getNumberByKey(BalanceUnlockBlockKey + owner)
func getOrderTotal(id : String) = getNumberByKey(OrderTotalKey + id)
func getOrderOwner(id : String) = getStringByKey(OrderOwnerKey + id)
func getOrderFilledTotal(id : String) = getNumberByKey(OrderFilledTotalKey + id)
func getRPDProfit(count: Int) = getNumberByKey(getRPDProfitKey(count))

#end data store function

func convertNeutrinoToWaves(amount: Int) = amount*100/price 
func convertWavesToNeutrino(amount: Int) = amount*price/100 
func convertNeutrinoToBond(amount: Int) = amount/Wavelet 
func convertBondToNeutrino(amount: Int) = amount*Wavelet 
func convertWavesToBond(amount: Int) = convertNeutrinoToBond(convertWavesToNeutrino(amount))
let surplus = convertWavesToNeutrino(reserve) - neutrinoSupply

let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"

func throwIfBlackSwarm() = {
    if(isBlocked)
        then throw("contract is blocked")
    else false
}

@Callable(i)
func finalizeCurrentPrice(newPrice : Int) = {
    let isBlackSwarm = throwIfBlackSwarm()
    let account = toString(i.caller)
    if(account != oracle)
        then throw("permission denied")
    else if(price + price*PercentPriceOffset/100 <= newPrice || price - price*PercentPriceOffset/100 >= newPrice) then {
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(BlackSwarmPriceKey + ListSplitSymbol + toString(height), newPrice)
        ])
    }
    else 
        WriteSet([
            DataEntry(PriceKey, price),
            DataEntry(PriceKey + ListSplitSymbol + toString(height), newPrice)
        ])
}

@Callable(i)
func adminUnlock(newPrice : Int) = {
    let account = toString(i.caller)
    let adminOneVote = if(account != ADMINONE) then getAdminVoteInt(ADMINONE) else 0
    let adminTwoVote = if(account != ADMINTWO) then getAdminVoteInt(ADMINTWO) else 0
    let adminThreeVote = if(account != ADMINTHREE) then getAdminVoteInt(ADMINTHREE) else 0
    
    let adminOnePrice = if(getAdminVotePrice(ADMINONE)*adminOneVote == newPrice) then 1  else 0
    let adminTwoPrice = if(getAdminVotePrice(ADMINTWO)*adminTwoVote == newPrice) then 1 else 0
    let adminThreePrice = if(getAdminVotePrice(ADMINTHREE)*adminThreeVote == newPrice) then 1 else 0
    
    if(!isBlocked) 
        then throw("Contract is not blocked")
    else if(adminOnePrice + adminTwoPrice + adminThreePrice + 1 >= 2 && height <= blockExpireVote) then {
        WriteSet([
            DataEntry(IsBlockedKey, false),
            DataEntry(PriceKey, newPrice),
            DataEntry(PriceKey + ListSplitSymbol + toString(height), newPrice),
            DataEntry(AdminVoteKey + ADMINONE, false),
            DataEntry(AdminVoteKey + ADMINTWO, false),
            DataEntry(AdminVoteKey + ADMINTHREE, false),
            DataEntry(BlockExpireVoteKey, 0)
        ])
    }else 
        WriteSet([
            DataEntry(AdminVotePriceKey + account, newPrice),
            DataEntry(BlockExpireVoteKey, if(height > blockExpireVote) then height + voteInterval else blockExpireVote),
            DataEntry(AdminVoteKey + ADMINONE, if(height > blockExpireVote) then false else adminOneVote),
            DataEntry(AdminVoteKey + ADMINTWO, if(height > blockExpireVote) then false else adminTwoVote),
            DataEntry(AdminVoteKey + ADMINTHREE, if(height > blockExpireVote) then false else adminThreeVote),
            DataEntry(AdminVoteKey + account, true)
        ])
}

@Callable(i)
func adminLock() = {
    let account = toString(i.caller)
    
    let adminOneVote = if(account != ADMINONE) then getAdminVoteInt(ADMINONE) else 1
    let adminTwoVote = if(account != ADMINTWO) then getAdminVoteInt(ADMINTWO) else 1
    let adminThreeVote = if(account != ADMINTHREE) then getAdminVoteInt(ADMINTHREE) else 1
    
    if(isBlocked) 
        then throw("Contract is blocked")
    else if(adminOneVote + adminTwoVote + adminThreeVote >= 2) then {
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(AdminVoteKey + ADMINONE, false),
            DataEntry(AdminVoteKey + ADMINTWO, false),
            DataEntry(AdminVoteKey + ADMINTHREE, false),
            DataEntry(BlockExpireVoteKey, 0)
        ])
    }
    else 
        WriteSet([
            DataEntry(BlockExpireVoteKey, if(height > blockExpireVote) then height + voteInterval else blockExpireVote),
            DataEntry(AdminVoteKey + ADMINONE, if(height > blockExpireVote) then false else adminOneVote),
            DataEntry(AdminVoteKey + ADMINTWO, if(height > blockExpireVote) then false else adminTwoVote),
            DataEntry(AdminVoteKey + ADMINTHREE, if(height > blockExpireVote) then false else adminThreeVote)
        ])
}

@Callable(i)
func swapWavesToNeutrino() = {
    let isBlackSwarm = throwIfBlackSwarm()
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) 
        then throw("can use waves only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertWavesToNeutrino(pmt.amount)
        WriteSet([
            DataEntry(NeutrinoBalanceKey + toString(i.caller), amount + getNeutrinoBalance(account)),
            DataEntry(BalanceUnlockBlockKey + toString(i.caller), height + balanceLockBlock)
        ])
    }
}

@Callable(i)
func swapNeutrinoToWaves() = {
    let isBlackSwarm = throwIfBlackSwarm()
    let pmt = extract(i.payment)
    if (pmt.assetId != neutrinoAssetId) 
        then throw("can use neutrino only")
    else{
        let account = toBase58String(i.caller.bytes)
        let amount = convertNeutrinoToWaves(pmt.amount)
        WriteSet([
            DataEntry(WavesBalanceKey + toString(i.caller), amount + getWavesBalance(account)),
            DataEntry(BalanceUnlockBlockKey + toString(i.caller), height + balanceLockBlock)
        ])
    }
}

@Callable(i)
func withdraw(account : String) = {
    if(getBalanceBlock(account) >= height)
        then throw("wait a couple of blocks for withdraw")
    else
        ScriptResult(
            WriteSet([
                DataEntry(WavesBalanceKey + account, 0),
                DataEntry(NeutrinoBalanceKey + account, 0)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(account), getNeutrinoBalance(account), neutrinoAssetId),
                ScriptTransfer(addressFromStringValue(account),  getWavesBalance(account), unit)
            ])
        )
}

@Callable(i)
func generateBond() = {
    let isBlackSwarm = throwIfBlackSwarm()
    let deficit = neutrinoSupply - convertWavesToNeutrino(reserve)
    let balanceAuction = assetBalance(addressFromStringValue(auctionContract), bondAssetId)
    let amount = convertNeutrinoToBond(deficit) - balanceAuction
    if(amount > 0)
        then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), amount, bondAssetId)])
    else throw("bond were generated or do not need it")
}

@Callable(i)
func setOrder() = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != bondAssetId) 
        then throw("can use bond only")
    else if(getOrderOwner(newOrderId) != "")
        then throw("order exists")
    else {
        WriteSet([
            DataEntry(OrderbookKey, orderbook + newOrderId + ListSplitSymbol),

            DataEntry(OrderTotalKey + newOrderId, pmt.amount),
            DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
            DataEntry(OrderHeightKey + newOrderId, height),
            DataEntry(OrderStatusKey + newOrderId, NEW)
        ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let parts = orderbook.split(orderId + ListSplitSymbol)

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, parts[0] + parts[1]),
                DataEntry(OrderStatusKey + orderId, CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, bondAssetId)
            ])
        )
    }
}

@Callable(i)
func executeOrder() = {
    let isBlackSwarm = throwIfBlackSwarm()
    let orderId = orderbook.split(ListSplitSymbol)[0]
    let orderTotal = getOrderTotal(orderId)
    let orderOwner = getOrderOwner(orderId)
    let filledTotal = getOrderFilledTotal(orderId)

    if(surplus <= 0) 
        then throw("surplus is less than zero")
    else if(orderOwner == "") then {
        let newRpdCount = rpdCount + 1
        ScriptResult(
            WriteSet([
                DataEntry(getRPDProfitKey(newRpdCount), surplus)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(surplus), neutrinoAssetId)
            ])
        )
    }
    else {
        let amount = orderTotal-filledTotal;
        let surplusBond = convertNeutrinoToBond(surplus)
        let status = if(surplusBond >= amount) then FILLED else NEW
        let newFilledTotal = if(surplusBond >= amount) then orderTotal else surplusBond

        ScriptResult(
            WriteSet([
                DataEntry(OrderbookKey, orderbook.split(orderId + ListSplitSymbol)[1]),
                DataEntry(OrderFilledTotalKey + orderId, filledTotal + newFilledTotal),
                DataEntry(OrderStatusKey + orderId, status)
            ]), 
            TransferSet([
                ScriptTransfer(addressFromStringValue(orderOwner), convertBondToNeutrino(newFilledTotal), neutrinoAssetId)
            ])
        )
    }
}

