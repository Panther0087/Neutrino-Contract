{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function

let NONE = ""

func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}

func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
}

#end base function

# data store function
let OrderBookKey = "orderbook"

let OrderPriceKey = "order_price_" 
let OrderTotalKey = "order_total_" 
let OrderFilledTotalKey = "order_filled_total_" 
let OrderOwnerKey = "order_owner_"
let OrderHeightKey = "order_height_"
let OrderStatusKey = "order_status_"

let BondAssetIdKey = "bond_asset_id"
let NeutrinoAssetIdKey = "neutrino_asset_id"
let NeutrinoContractKey = "neutrino_contract"

let orderbook = getStringByKey(OrderBookKey)

func getOrderPrice(id : String) = {
    getNumberByKey(OrderPriceKey + id)
}
func getOrderTotal(id : String) = {
    getNumberByKey(OrderTotalKey + id)
}
func getOrderOwner(id : String) = {
    getStringByKey(OrderOwnerKey + id)
}
func getOrderStatus(id : String) = {
    getStringByKey(OrderStatusKey + id)
}
func getOrderFilledTotal(id : String) = {
    getNumberByKey(OrderFilledTotalKey + id)
}

#end data store function

let OrderSplitSymbol = "_"
let BondAssetId = fromBase58String(getStringByKey(BondAssetIdKey))
let NeutrinoAssetId = fromBase58String(getStringByKey(NeutrinoAssetIdKey))
let NeutrinoContract = getStringByKey(NeutrinoContractKey)
let Wavelet = 100000000

let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"

func calculateOrderbook(orderId: String, position: Int) = {
    let orders = orderbook.split(OrderSplitSymbol)
    let newOrder = orderId + OrderSplitSymbol
    if(position == 0) 
        then newOrder + orderbook 
    else if(position >= size(orders) - 1) 
        then orderbook + newOrder 
    else {
        let parts = orderbook.split(orders[position] + OrderSplitSymbol)
        parts[0] + newOrder + (orders[position] + OrderSplitSymbol) + parts[1]
    }
}

@Callable(i)
func setOrder(price : Int, position: Int) = {
    let pmt = extract(i.payment);
    let newOrderId = toBase58String(keccak256(toBytes(price) + toBytes(pmt.amount) + i.caller.bytes + toBytes(height)))

    if (pmt.assetId != NeutrinoAssetId) 
        then throw("can use neutrino only")
    else if(price <= 0)
        then throw("price less zero")
    else if(getOrderOwner(newOrderId) != NONE)
        then throw("order exists")
    else {
        let orders = orderbook.split(OrderSplitSymbol)

        let nextOrderId = if(position == 0) then "" else orders[position-1];
        let nextOrderPrice = getOrderPrice(nextOrderId)
        let isNextOrderError = if(nextOrderId != "" && price > nextOrderPrice) then true else false;
        
        let prevOrderId = orders[position];
        let prevOrderPrice = getOrderPrice(prevOrderId)
        let isPrevOrderError = if(price <= prevOrderPrice) then true else false;
        
        if (isNextOrderError || isPrevOrderError)
            then throw("invalid order isPrevOrderError:" + toString(isPrevOrderError) + " isNextOrderError:" + toString(isNextOrderError))
        else
            WriteSet([
                DataEntry(OrderBookKey, calculateOrderbook(newOrderId, position)),

                DataEntry(OrderPriceKey + newOrderId, price),
                DataEntry(OrderTotalKey + newOrderId, pmt.amount),
                DataEntry(OrderOwnerKey + newOrderId, toString(i.caller)),
                DataEntry(OrderHeightKey + newOrderId, height),
                DataEntry(OrderStatusKey + newOrderId, NEW)
            ])
    }
}

@Callable(i)
func cancelOrder(orderId : String) = {
    let owner = getOrderOwner(orderId)
    let amount = getOrderTotal(orderId) - getOrderFilledTotal(orderId)
    if(owner != toString(i.caller)) 
        then throw("permission denied")
    else {
        let parts = orderbook.split(orderId + OrderSplitSymbol)

        ScriptResult(
            WriteSet([
                DataEntry(OrderBookKey, parts[0] + parts[1]),

                DataEntry(OrderStatusKey + orderId, CANCELED)
            ]), 
            TransferSet([
                ScriptTransfer(i.caller, amount, NeutrinoAssetId)
            ])
        )
    }
}

@Callable(i)
func execute() = {
    let orderId = orderbook.split(OrderSplitSymbol)[0]

    let bondAmount = assetBalance(this, BondAssetId)

    let filledTotal = getOrderFilledTotal(orderId)
    let orderTotal = getOrderTotal(orderId)
    let orderPrice = getOrderPrice(orderId)
    let amount = (orderTotal-filledTotal)*100/orderPrice/Wavelet;
    
    let newOrderbook = if(bondAmount >= amount) then orderbook.split(orderId + OrderSplitSymbol)[1] else orderbook
    let filledAmount = if(bondAmount >= amount) then amount else bondAmount

    let total = filledAmount*orderPrice/100*Wavelet;

    let status = if(bondAmount >= amount) then FILLED else NEW

    ScriptResult(
        WriteSet([
            DataEntry(OrderBookKey, newOrderbook),
            DataEntry(OrderFilledTotalKey + orderId, filledTotal + total),
            DataEntry(OrderStatusKey + orderId, status)
        ]), 
        TransferSet([
            ScriptTransfer(i.caller, filledAmount, BondAssetId),
            ScriptTransfer(addressFromStringValue(NeutrinoContract), total, NeutrinoAssetId)
        ])
    )
}